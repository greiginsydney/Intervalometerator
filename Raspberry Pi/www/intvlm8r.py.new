# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
# This script is part of the Intervalometerator project, a time-lapse camera controller for DSLRs:
# https://github.com/greiginsydney/Intervalometerator
# https://greiginsydney.com/intvlm8r
# https://intvlm8r.com
#
# This script incorporates code from python-gphoto2, and we are incredibly indebted to Jim Easterbrook for it.
# python-gphoto2 - Python interface to libgphoto2 http://github.com/jim-easterbrook/python-gphoto2 Copyright (C) 2015-17 Jim
# Easterbrook jim@jim-easterbrook.me.uk



from collections import namedtuple # used by psutil on the /network page
from datetime import timedelta, datetime, timezone
from decimal import Decimal     # Thumbs exposure time calculations
from packaging import version   # getArduinoVersion and related
from PIL import Image           # Camera page preview button
from urllib.parse import urlparse, urljoin # Login
import configparser             # Ini file
import fnmatch                  # Testing filenames
import gphoto2 as gp
import importlib.util           # Testing installed packages
import inspect                  # /network page
import io                       # Camera preview
import json
import logging
import math                     # Ceiling in /thermal calcs
import os                       # Hostname
import psutil
import re                       # RegEx. Used in Copy Files & createDestFilename
import requests                 # Heartbeat
from smbus2 import SMBus        # I2C
import socket                   # Heartbeating error trap
import struct
import subprocess
import sys
import time

# Protect against missing components (specific to thumbs)
try:
    import exifreader           # Thumbnails
    import imageio              # Thumbnails
    import rawpy                # Thumbnails
except:
    pass                        # I can't log anything here because logging hasn't been initiated yet

from werkzeug.security import check_password_hash

from flask import Flask, flash, render_template, request, redirect, url_for, make_response, abort, jsonify, g, send_from_directory, session
from flask_login import LoginManager, current_user, login_user, logout_user, login_required, UserMixin, login_url
from flask_caching import Cache
from celery import Celery, chain
from celery.app.control import Inspect

app = Flask(__name__)
app.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'
app.config['result_backend'] = 'redis://localhost:6379/0'
# app.config["TEMPLATES_AUTO_RELOAD"] = True # Uncomment when debugging

app.secret_key = b'### Paste the secret key here. See the Setup docs ###' #Cookie for session messages
app.jinja_env.lstrip_blocks = True
app.jinja_env.trim_blocks = True

celery = Celery(app.name,
                broker=app.config['CELERY_BROKER_URL'],
                backend=app.config['result_backend'],
                broker_connection_retry_on_startup = True,
                broker_connection_retry = True
                )
celery.conf.update(app.config)

cache = Cache(app, config={'CACHE_TYPE': 'RedisCache', 'CACHE_REDIS_URL': 'redis://localhost:6379/0'})

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = ''

#Deep gphoto logging enabled when debugging:
callback_obj = gp.check_result(gp.use_python_logging(mapping={
    gp.GP_LOG_ERROR   : logging.INFO,
    gp.GP_LOG_DEBUG   : logging.DEBUG,
    gp.GP_LOG_VERBOSE : logging.DEBUG - 3,
    gp.GP_LOG_DATA    : logging.DEBUG - 6}))

# ////////////////////////////////
# /////////// STATICS ////////////
# ////////////////////////////////

PI_USER_HOME =  os.path.expanduser('~')
PI_PHOTO_DIR  = os.path.join(PI_USER_HOME, 'photos')
PI_PHOTO_RENAME_FILE = os.path.join(PI_PHOTO_DIR, 'piPhotoRename.txt')
PI_THUMBS_DIR = os.path.join(PI_USER_HOME, 'thumbs')
PI_THUMBS_INFO_FILE = os.path.join(PI_THUMBS_DIR, 'piThumbsInfo.txt')
PI_PREVIEW_DIR = os.path.join(PI_USER_HOME, 'preview')
PI_PREVIEW_FILE = 'intvlm8r-preview.jpg'
PI_TRANSFER_DIR = os.path.join(PI_USER_HOME, 'www/static')
PI_TRANSFER_FILE = os.path.join(PI_TRANSFER_DIR, 'piTransfer.log')
PI_HBRESULT_FILE = os.path.join(PI_USER_HOME, 'hbresults.txt')
gunicorn_logger = logging.getLogger('gunicorn.error')
REBOOT_SAFE_WORD = 'seeyasoon'
HOSTNAME = os.uname()[1]
RAWEXTENSIONS = ('.CR2', '.NEF')
PI_SPACE_RESERVED = 10 * 2**20 # 10 * 1M - the amount of drive space the Pi needs to keep spare
TIME_SETTING_OPTIONS = [(1,'syncdatetime'), (2,'syncdatetimeutc'), (4,'datetime'), (8,'datetimeutc')]

# /////// VERSION-RELATED STATICS ////////
# UI components (features) will display if the Arduino is running this version or later:
SHOW_TEMPS24     = "4.5.0"
SHOW_VOLTS24     = "4.5.4"
SHOW_SHUTDOWN_IN = "4.5.5"

# Our user database:
#users = {'admin': {'password': '### Paste the hash of the password here. See the Setup docs ###'}}
users = {'admin': {'password': 'password'}}
#users.update({'superuser': {'password': 'godmode'}}) #Un-comment, copy and update this line as required to add more user logins

app.logger.handlers = gunicorn_logger.handlers
app.logger.setLevel(gunicorn_logger.level)

bus = SMBus(1) #Initalise the I2C bus
# This is the address we setup in the Arduino Program
address = 0x04

iniFile = os.path.join(app.root_path, 'intvlm8r.ini')

arduinoDoW = ["Unknown", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]

cameraPreviewBlocklist = [""]

#Suppress the display of any uninstalled transfer options:
hiddenTransferOptions = ''
hiddenTransferDict = {
  "paramiko": "SFTP",
  "dropbox": "Dropbox",
  "sysrsync": "rsync"
}
# TY SO: https://stackoverflow.com/a/41815890
for package_name in ('paramiko', 'dropbox', 'sysrsync'):
    spec = importlib.util.find_spec(package_name)
    if spec is None:
        app.logger.debug(f'{package_name} is not installed')
        hiddenTransferOptions = hiddenTransferOptions + "," + hiddenTransferDict[package_name]
app.logger.debug(f'hiddenTransferOptions = {hiddenTransferOptions}')

def writeString(value, waitTime):
    ascii = [ord(c) for c in value]
    for x in range(0, 2):
        try:
            bus.write_i2c_block_data(address, 0, ascii)
            break   # Break out of the retry loop if we get to here
        except Exception as e:
            app.logger.debug(f'writeString error: {e}')
            time.sleep(1) # Wait a second before each retry
    if not waitTime == 0:
        time.sleep(waitTime)  # Give the Arduino time to act on the data sent
    return -1


def readFromArduino(value, dataType, cacheRequest):
    ascii = ord(value[0])
    if (cacheRequest == True):
        cached = cache.get(value)
        if cached is None:
            #The cache is empty? Bummer
            pass
        else:
            app.logger.debug(f"ASCII = {ascii}. Returned cached value '{cached}'")
            return cached

    status = ""
    app.logger.debug(f'ASCII = {ascii}')
    rxLength = 32

    for x in range(0, 2):
        try:
            array = bus.read_i2c_block_data(address, ascii, rxLength)
            if dataType == "Binary":
                status = array
                break
            for i in range(len(array)):
                 if (array[i] == 0):
                     break
                 status += chr(array[i])
            break   # Break out of the retry loop if we get to here
        except Exception as e:
            app.logger.debug(f'readFromArduino error: {e}')
            time.sleep(1) # Wait a second before each retry
    app.logger.debug(f'Status received was {dataType}: >{status}<')

    if (cacheRequest == True):
        cache.set(value, status, timeout = 0)

    if status == "":
        status = "Unknown"
    return status


def getPiUptime():
    uptime_string = "Unknown"
    try:
        with open('/proc/uptime', 'r') as f:
            uptime_seconds = float(f.readline().split()[0])
            uptime_string = str(timedelta(seconds = round(uptime_seconds)))
    except Exception as e:
        app.logger.debug(f'Exception in getPiUptime: {e}')
    return uptime_string


def getPiTemp():
    temp = "Unknown"
    try:
        with open('/sys/class/thermal/thermal_zone0/temp', 'r') as tempfile:
            temp = '{0:.0f}'.format(round(int(tempfile.read()) / 1000, 0))
    except Exception as e:
        app.logger.debug(f'Pi temp error: {e}')
    app.logger.debug(f'Pi temp = {temp}')
    return temp


def getArduinoVersion(returnValue):
    try:
        rawArduinoVersion = str(readFromArduino("6", "String", False))
        arduinoVersion = version.Version(rawArduinoVersion)  # This will throw if it's not a valid version
        returnValue = arduinoVersion
    except version.InvalidVersion as e:
        app.logger.debug(f'getArduinoVersion: InvalidVersion error: {e}')
    except Exception as e:
        app.logger.debug(f'getArduinoVersion: Unexpected error: {e}')
    app.logger.debug(f'getArduinoVersion returned {returnValue}')
    return returnValue


@app.context_processor
def customisation():
    loc = cache.get('locationName')
    if loc is None:
        #The cache is empty? Read the location from the Ini file
        loc = getIni('Global', 'locationName', 'string', 'Intvlm8r')
        cache.set('locationName', loc, timeout = 0)
    return dict (locationName = loc )


def is_safe_url(target):
    ref_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


class User(UserMixin):
    pass


@login_manager.user_loader
def user_loader(username):
    if username not in users:
        return None
    user = User()
    user.id = username
    return user


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'GET':
        app.logger.debug("It's a GET to LOGIN")
        return render_template('login.html')
    username = (str(request.form['username']))
    remember = 'false'
    for name, _ in users.items():
        if (username.casefold() == name.casefold()):
            #OK, we have the user name (regardless of the case)!
            if users[name]['password'] == request.form['password']:
            #if (check_password_hash(users[username]['password'], request.form['password'])):
                user = User()
                user.id = name
                if request.form.get('rememberme'):
                    remember = 'true'
                login_user(user,'remember=' + remember)
                app.logger.debug(f'Logged-in {name}')
                next = request.args.get('next')
                # is_safe_url should check if the url is safe for redirects.
                # See http://flask.pocoo.org/snippets/62/ for an example.
                if not is_safe_url(next):
                    return abort(400)
                return redirect(next or url_for('main'))
    app.logger.debug(f"User '{username}' failed to login")
    flash('Bad creds. Try again', 'red')
    return redirect(url_for('login'))


@app.route("/logout")
@login_required
def logout():
    logout_user()
    try:
        session['_flashes'].clear() #Clears any lingering messages the user is now no longer authorised to see
    except:
        pass
    flash('You have been logged out', 'info')
    return redirect(url_for('login'))


@login_manager.unauthorized_handler
def unauthorized_handler():
    flash('You need to log in before you can access that page!', 'red')
    return redirect(login_url(url_for('login'), request.url))


@app.route("/")
@login_required
def main():
    templateData = {
        'arduinoDate'       : 'Unknown',
        'arduinoTime'       : '',
        'arduinoLastShot'   : 'Unknown',
        'arduinoNextShot'   : 'Unknown',
        'cameraBattery'     : 'Unknown',
        'fileCount'         : 'Unknown',
        'lastImage'         : 'Unknown',
        'availableShots'    : 'Unknown',
        'cameraDaysFree'    : 'Unknown',
        'piInterval'        : '',
        'piImageCount'      : 'Unknown',
        'piLastImage'       : 'Unknown',
        'piSpaceFree'       : 'Unknown',
        'piDaysFree'        : 'Unknown',
        'daysFreeWarn'      : '0',
        'daysFreeAlarm'     : '0',
        'lastTrnResult'     : 'Unknown',
        'lastTrnLogFile'    : '',
        'piLastImageFile'   : 'Unknown',
        'cameraUsbMode'     : 'false' # Jinja requires bools in lower case
    }

    app.logger.debug('YES - this bit of MAIN fired!')

    camera, context, config, usbMode = connectCamera(4) # Check the camera: see if it's awake, and if not, just wake it and return
    templateData['cameraUsbMode'] = usbMode

    arduinoDate = getArduinoDate() # Failure returns "Unknown"
    templateData['arduinoDate'] = arduinoDate
    if arduinoDate != 'Unknown':
        templateData['arduinoTime'] = getArduinoTime() # Failure returns "", but *might* also report midnight in the absence of a working RTC!

    try:
        arduinoStats = str(readFromArduino("2", "String", False))
        if arduinoStats != "Unknown":
            lastShot= arduinoStats.split(":")[0]
            if lastShot != "19999":
                templateData['arduinoLastShot'] = arduinoDoW[int(lastShot[0:1])] + " " + lastShot[1:3]+ ":" + lastShot[3:5]
            nextShot = arduinoStats.split(":")[1]
            if nextShot != "19999":
                ArdInterval = str(readFromArduino("3", "String", False))
                interval  = int(ArdInterval[5:7])
                if interval > 60:
                    # shootFast
                    sfInterval = str(interval - 60)
                    templateData['arduinoNextShot'] = "(every " + sfInterval + "s) " + arduinoDoW[int(nextShot[0:1])] + " " + nextShot[1:3]+ ":" + nextShot[3:5]
                else:
                    templateData['arduinoNextShot'] = arduinoDoW[int(nextShot[0:1])] + " " + nextShot[1:3]+ ":" + nextShot[3:5]
    except Exception as e:
        app.logger.debug(f'Time template error in /home: {e}')

    # Camera comms:
    try:
        if not config:
            camera, context, config, discardMe = connectCamera(1)
        if camera:
            storage_info = gp.check_result(gp.gp_camera_get_storageinfo(camera))
            if len(storage_info) == 0:
                flash('No storage info available', 'red') # The memory card is missing or faulty
                app.logger.debug('FATAL: Connected to camera OK but no camera storage info available')
            files = list_camera_files(camera)
            if not files:
                fileCount = 0
                lastImage = 'n/a'
            else:
                fileCount = len(files)
                info = get_camera_file_info(camera, files[-1]) #Get the last file
                lastImage = datetime.utcfromtimestamp(info.file.mtime).isoformat(' ')
            templateData['fileCount']                = fileCount
            templateData['lastImage']                = lastImage
            templateData['cameraBattery'], discardMe = readRange (camera, 'status', 'batterylevel')

            #Find the capturetarget config item. (TY Jim.)
            capture_target = gp.check_result(gp.gp_widget_get_child_by_name(config, 'capturetarget'))
            currentTarget = gp.check_result(gp.gp_widget_get_value(capture_target))
            #app.logger.debug(f'Current captureTarget =  {currentTarget}')
            if currentTarget == "Internal RAM":
                #Change it to "Memory Card"
                try:
                    newTarget = 1
                    newTarget = gp.check_result(gp.gp_widget_get_choice(capture_target, newTarget))
                    gp.check_result(gp.gp_widget_set_value(capture_target, newTarget))
                    gp.check_result(gp.gp_camera_set_config(camera, config))
                    config = camera.get_config(context) #Refresh the config data for the availableshots to be read below
                    app.logger.debug('Set captureTarget to "Memory Card" in main')
                except gp.GPhoto2Error as e:
                    app.logger.debug(f'GPhoto camera error setting capturetarget in main: {e}')
                except Exception as e:
                    app.logger.debug(f'Unknown camera error setting capturetarget in main: {e}')
            templateData['availableShots'] = readValue (config, 'availableshots')
            camera.exit()
    except Exception as e:
        app.logger.debug(f'Unknown camera error in main: {e}')

    # Pi comms:
    piLastImage = ''
    piLastImageFile = ''
    try:
        FileList = list_Pi_Images(PI_PHOTO_DIR)
        PI_PHOTO_COUNT = len(FileList)
        if PI_PHOTO_COUNT >= 1:
            FileList.sort(key=lambda x: os.path.getmtime(x))
            piLastImage = datetime.utcfromtimestamp(os.path.getmtime(FileList[-1])).replace(microsecond=0)
            piLastImageFile = str(FileList[-1])
            #This code ensures if you're shooting RAW, the main page still shows a photo. It uses (in priority order):
            # 1: its preview
            # 2: its .JPG twin - if one exists. (You're shooting in RAW+JPG mode)
            # 3: its thumbnail (yuk).
            if piLastImageFile.endswith(RAWEXTENSIONS):
                piLastImageFileAsJpg = re.sub('|'.join(RAWEXTENSIONS), ".JPG", piLastImageFile)
                piLastImageFilePreview = createDestFilename(piLastImageFile, PI_PREVIEW_DIR, '-preview')
                if os.path.isfile(piLastImageFilePreview):
                    piLastImageFile = 'preview/' + piLastImageFilePreview.replace((PI_PREVIEW_DIR  + "/"), "")
                elif os.path.isfile(piLastImageFileAsJpg):
                    piLastImageFile = piLastImageFileAsJpg
                    piLastImageFile = 'photos/' + piLastImageFile.replace((PI_PHOTO_DIR  + "/"), "")
                else:
                    piLastImageFile = 'thumbs/' + piLastImageFileAsJpg.replace((PI_PHOTO_DIR  + "/"), "")
                    piLastImageFile = piLastImageFile.replace(".JPG", "-thumb.JPG")
            else:
                # piLastImageFile = 'default_image.JPG' # Uncomment this line to prevent a high-res image being shown on the home page. (Only happens if thumbs=0)
                piLastImageFile = 'photos/' + piLastImageFile.replace((PI_PHOTO_DIR  + "/"), "")
            if ('/home/pi/photos/default_image.JPG' in FileList):
                PI_PHOTO_COUNT -= 1
                if (PI_PHOTO_COUNT == 0):
                    piLastImage = 'n/a'
    except Exception as e:
        flash('Error talking to the Pi', 'red')
        app.logger.debug(f'Pi error: {e}')
        PI_PHOTO_COUNT = 0
    templateData['piLastImageFile'] = piLastImageFile
    templateData['piImageCount']    = PI_PHOTO_COUNT
    templateData['piLastImage']     = piLastImage
    templateData['piSpaceFree'],piBytesFree = getDiskSpace()
    largestImageSize = getLargestImageSize(PI_PHOTO_DIR)
    shotsPerDay = getShotsPerDay()
    #Python rounds up, which I don't want. This "- 0.5" is also to align with the same result calculated by Javascript on the /intervalometer page.
    try:
        templateData['piDaysFree'] = str(round(((piBytesFree / largestImageSize) / shotsPerDay) - 0.5))
    except:
        pass
    try:
        templateData['cameraDaysFree'] = round((int(templateData['availableShots']) / shotsPerDay) - 0.5)
    except:
        pass
    templateData['daysFreeWarn']  = int(getIni('Thresholds', 'daysfreewarn', 'int', '14'))
    templateData['daysFreeAlarm']  = int(getIni('Thresholds', 'daysfreealarm', 'int', '7'))

    templateData['lastTrnLogFile'] = PI_TRANSFER_FILE.replace(PI_TRANSFER_DIR,'static')
    try:
        with open(PI_TRANSFER_FILE, 'r') as f:
            for line in reversed(f.read().splitlines()):
                if 'STATUS: ' in line:
                    templateData['lastTrnResult'] = line.replace('STATUS: ','')
                    break
    except Exception as e:
        app.logger.debug(f'Exception reading STATUS in piTransfer.log file: {e}')
    return render_template('main.html', **templateData)


@app.route("/", methods = ['POST'])
@login_required
def mainPOST():
    """
    Just wake the camera and return to main
    Purely so we can capture the 'wake camera' button for the progress message
    """
    writeString("WC", 2) # Sends the WAKE command to the Arduino
    app.logger.debug('main page POSTed the camera wake command')
    return redirect(url_for('main'))


@app.route("/getTime")
def getTime():
    """
    This 'page' is only one of three called without the "@login_required" decorator. It's only called by
    the cron job/ setTime.py script and will only execute if the calling IP is itself/localhost.
    """
    sourceIp = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    if sourceIp != "127.0.0.1":
        abort(403)
    arduinoDate = getArduinoDate()
    arduinoTime = getArduinoTime()
    res = make_response(f'<div id="dateTime">{arduinoDate} {arduinoTime}</div>')
    return res, 200


@app.route("/setArduinoDateTime")
def setArduinoDateTime():
    """
    This 'page' is only one of three called without the "@login_required" decorator. It's only called by
    the cron job/ setTime.py script and will only execute if the calling IP is itself/localhost.
    """
    sourceIp = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    if sourceIp != "127.0.0.1":
        abort(403)

    newTime = datetime.now().strftime('%Y%m%d%H%M%S') #20190613235900
    writeString(f'ST={newTime}', 1) # Send the new time and date to the Arduino
    app.logger.debug(f'setArduinoDateTime to {newTime}')
    res = make_response(f'<p>Set Arduino datetime to {newTime}</p>')
    return res, 200


def getArduinoDate():
    formattedDate = 'Unknown'
    try:
        rawDate = str(readFromArduino("0", "String", False))
        if rawDate != 'Unknown':
            formattedDate = datetime.strptime(rawDate, '%Y%m%d').strftime('%Y %b %d')
        time.sleep(0.5);
    except Exception as e:
        app.logger.debug(f'Exception in getArduinoDate: {e}')
    return formattedDate


def getArduinoTime():
    formattedTime = ''
    try:
        rawTime = str(readFromArduino("1", "String", False))
        if rawTime != 'Unknown':
            formattedTime = rawTime[0:2] + ":" + rawTime[2:4] + ":" + rawTime[4:6]
        time.sleep(0.5);
    except Exception as e:
        app.logger.debug(f'Exception in getArduinoTime: {e}')
    return formattedTime


@app.route("/thumbnails")
@login_required
def thumbnails():
    """
    The logic here warrants some explanation: It's *assumed* that for every photo on the Pi there's a matching thumbnail, as the
    copy and thumb creation process are linked. You *shouldn't* have one without the other.
    This code creates the thumbnails list based on the filename of the main image, and then only adds the assumed -thumbs.JPG suffix as it calls the view.
    Thus, even if a thumb is absent (broken?), the view will still reveal its main image, the image's metadata, and you can still click-through to see it.

    Had I started with "list_Pi_Images(PI_THUMBS_DIR)", then a missing thumb would result in its main image not being displayed here.
    """
    ThumbFiles = []
    ThumbsToShow = int(getIni('Global', 'thumbsCount', 'int', '24'))

    try:
        FileList  = list_Pi_Images(PI_PHOTO_DIR)
        PI_PHOTO_COUNT = len(FileList)
        if PI_PHOTO_COUNT >= 1:
            FileList.sort(key=lambda x: os.path.getmtime(x))
            ThumbnailCount = min(ThumbsToShow,PI_PHOTO_COUNT) # The lesser of these two values
            #Read all the thumb exifData ready to create the page:
            ThumbsInfo = {}
            if os.path.isfile(PI_THUMBS_INFO_FILE):
                with open(PI_THUMBS_INFO_FILE, 'rt') as f:
                    for line in f:
                        if ' = ' in line:
                            try:
                                (key, val) = line.rstrip('\n').split(' = ')
                                ThumbsInfo[key] = val
                            except Exception as e:
                                #Skip over bad line
                                app.logger.debug(f'Error in thumbs info file: {e}')
            #Read the thumb files themselves:
            for loop in range(-1, (-1 * (ThumbnailCount + 1)), -1):
                _, imageFileName = os.path.split(FileList[loop])
                #Read the exifData:
                thumbTimeStamp = 'Unknown'
                thumbInfo = 'Unknown'
                exifData = ThumbsInfo.get(imageFileName)
                #app.logger.debug(str(exifData))
                if exifData != None:
                    thumbTimeStamp = exifData.split("|")[0]
                    thumbInfo = exifData.split("|")[1]
                #Build the list for the page:
                ThumbFileName = createDestFilename(FileList[loop], PI_THUMBS_DIR, '-thumb') #Adds the '-thumb.JPG' suffix
                if FileList[loop].endswith(RAWEXTENSIONS):
                    PreviewFileName = createDestFilename(FileList[loop], PI_PREVIEW_DIR, '-preview') #Switch to the /PREVIEW/ folder
                    if not os.path.isfile(PreviewFileName):
                        PreviewFileName = ThumbFileName
                        app.logger.debug(f'No preview of RAW image {FileList[loop]}')
                else:
                    PreviewFileName = createDestFilename(FileList[loop], PI_PHOTO_DIR, '') #Switch to the /PHOTOS/ folder
                PreviewFileName = PreviewFileName.replace(PI_USER_HOME + '/', '')
                ThumbFileName = ThumbFileName.replace(PI_USER_HOME + '/', '')
                ThumbFiles.append({'PreviewImage': str(PreviewFileName), 'ThumbImage': str(ThumbFileName), 'TimeStamp': thumbTimeStamp, 'Info': thumbInfo })
        else:
            flash('There are no images on the Pi. Copy some from the Transfer page.', 'info')
    except Exception as e:
        app.logger.debug(f'Thumbs error: {e}')

    if ThumbsToShow == 0:
        flash('Thumbnail generation disabled', 'info')
    else:
        if (getIni('Transfer', 'deleteAfterTransfer', 'bool', 'Off')):
            flash('Delete after transfer is active', 'orange')

    return render_template('thumbnails.html', ThumbFiles = ThumbFiles)


@app.route("/camera")
@login_required
def camera():
    cameraData = {
        'cameraModel'     : '',
        'cameraLens'      : 'Unknown',
        'cameraDate'      : '',
        'focusmode'       : '',
        'exposuremode'    : '',
        'autopoweroff'    : '',
        'imgfmtselected'  : '',
        'imgfmtoptions'   : '',
        'wbselected'      : '',
        'wboptions'       : '',
        'isoselected'     : '',
        'isooptions'      : '',
        'apselected'      : '',
        'apoptions'       : '',
        'shutselected'    : '',
        'shutoptions'     : '',
        'expselected'     : '',
        'expoptions'      : '',
        'piPreviewFile'   : '',
        'cameraMfr'       : 'Unknown',
        'blockPreview'    : 'False',
        'enableCameraUsb' : 'false' # Jinja requires bools in lower case
        }

    args = request.args.to_dict()
    if args.get('preview'):
        cameraData['piPreviewFile'] = PI_PREVIEW_FILE + '?' + str(int(time.time())) #Adds a unique suffix so the browser always downloads the file

    camera, context, config, usbMode = connectCamera(1)
    if usbMode == 'true':
        cameraData['enableCameraUsb'] = 'true'
        try:
            if camera:
                abilities = camera.get_abilities()
                cameraData['cameraModel']              = abilities.model
                cameraData['cameraLens'], discardMe    = readRange (camera, 'status', 'lensname')
                if (cameraData['cameraLens'] == 'Unknown'):
                    #Try to build this from focal length:
                    focalMin, discardMe = readRange (camera, 'status', 'minfocallength')
                    focalMax, discardMe = readRange (camera, 'status', 'maxfocallength')
                    if (focalMin == focalMax):
                        cameraData['cameraLens'] = focalMin
                    else:
                        focalMin = focalMin.replace(" mm", "")
                        cameraData['cameraLens'] = (f'{focalMin}-{focalMax}')
                cameraTimeAndDate = getCameraTimeAndDate(camera, config, 'Unknown')
                cameraMfr, discardMe = readRange (camera, 'status', 'manufacturer')
                if 'Nikon' in cameraMfr:
                    cameraMfr = 'Nikon'
                    cameraData['cameraMfr'] = 'Nikon'
                elif 'Canon' in cameraMfr:
                    cameraMfr = 'Canon'
                    cameraData['cameraMfr'] = 'Canon'
                if (cameraMfr == 'Nikon'):
                    imgfmtselected, imgfmtoptions   = readRange (camera, 'capturesettings', 'imagequality')
                    apselected, apoptions           = readRange (camera, 'capturesettings', 'f-number')
                    cameraData['exposuremode']      = readValue (config, 'expprogram')
                else:
                    imgfmtselected, imgfmtoptions   = readRange (camera, 'imgsettings', 'imageformat')
                    apselected, apoptions           = readRange (camera, 'capturesettings', 'aperture')
                    cameraData['exposuremode']      = readValue (config, 'autoexposuremode')
                #Attributes generic to all cameras:
                wbselected, wboptions           = readRange (camera, 'imgsettings', 'whitebalance')
                isoselected, isooptions         = readRange (camera, 'imgsettings', 'iso')
                shutselected, shutoptions       = readRange (camera, 'capturesettings', 'shutterspeed')
                expselected, expoptions         = readRange (camera, 'capturesettings', 'exposurecompensation')

                abilities = camera.get_abilities()
                if abilities.model in cameraPreviewBlocklist:
                    cameraData['blockPreview']  = 'True'

                camera.exit()
                cameraData['cameraDate']    = cameraTimeAndDate
                cameraData['focusmode']     = readValue (config, 'focusmode')
                cameraData['exposuremode']  = readValue (config, 'autoexposuremode')
                if (cameraData['exposuremode'] == "Not available"):
                    #try "expprogram"
                    cameraData['exposuremode']  = readValue (config, 'expprogram')
                cameraData['autopoweroff']  = readValue (config, 'autopoweroff')
                cameraData['imgfmtselected']= imgfmtselected
                cameraData['imgfmtoptions'] = imgfmtoptions
                cameraData['wbselected']    = wbselected
                cameraData['wboptions']     = wboptions
                cameraData['isoselected']   = isoselected
                cameraData['isooptions']    = isooptions
                cameraData['apselected']    = apselected
                cameraData['apoptions']     = apoptions
                cameraData['shutselected']  = shutselected
                cameraData['shutoptions']   = shutoptions
                cameraData['expselected']   = expselected
                cameraData['expoptions']    = expoptions
        except Exception as e:
            app.logger.debug(f'Unknown camera GET error: {e}')
    else:
        app.logger.debug('nothing to display: cameraUsbMode is false')

    templateData = cameraData.copy()
    return render_template('camera.html', **templateData)


@app.route("/camera", methods = ['POST'])    # The camera's POST method
@login_required
def cameraPOST():
    """
    This page is where you manage all the camera settings
    """
    preview = None

    if 'wakeCamera' in request.form:
        writeString("WC", 2) # Sends the WAKE command to the Arduino
        app.logger.debug('camera page POSTed the camera wake command')
    elif 'enableCameraUsb' in request.form:
        # This is only ever present when the box is checked, and we can't be sure if the user changed it or not.
        if (request.form.get('cameraUsbToggled') == 'true'):
            # The camera has just been enabled. Update the cache/ INI and return.
            app.logger.debug('camera page POSTed that the USB on/off checkbox has been toggled')
            setIni('Global', 'enableCameraUsb', 'True')
            cache.set('enableCameraUsb', True)
            # Falls through to the bottom of the page and returns the redirect
        else:
            try:
                camera, context, config, discardMe = connectCamera(1)
                if camera:
                    if 'camApply' in request.form:
                        app.logger.debug('-- Camera Apply selected')
                        cameraMfr = request.form.get('cameraMfr')
                        app.logger.debug(f'cameraMfr = {cameraMfr}')
                        if cameraMfr == 'Canon':
                            #This *does* write a new setting to the camera:
                            node = config.get_child_by_name('imageformat') #
                            node.set_value(str(request.form.get('img')))
                            if (request.form.get('aperture') != None):
                                node = config.get_child_by_name('aperture')
                                node.set_value(str(request.form.get('aperture')))
                        elif cameraMfr == 'Nikon':
                            #This *does* write a new setting to the camera:
                            node = config.get_child_by_name('imagequality') #
                            node.set_value(str(request.form.get('img')))
                            if (request.form.get('aperture') != None):
                                node = config.get_child_by_name('f-number')
                                node.set_value(str(request.form.get('aperture')))
                        else:
                            pass
                        # Don't bother sending any of the "read only" settings:
                        if (request.form.get('wb') != None):
                            node = config.get_child_by_name('whitebalance')
                            node.set_value(str(request.form.get('wb')))
                        if (request.form.get('iso') != None):
                            node = config.get_child_by_name('iso')
                            node.set_value(str(request.form.get('iso')))
                        if (request.form.get('shutter') != None):
                            node = config.get_child_by_name('shutterspeed')
                            node.set_value(str(request.form.get('shutter')))
                        if (request.form.get('exp') != None):
                            node = config.get_child_by_name('exposurecompensation')
                            node.set_value(str(request.form.get('exp')))
                        camera.set_config(config, context)

                    if 'camPreview' in request.form:
                        app.logger.debug('-- Camera Preview selected')
                        getPreviewImage(camera, config)
                        preview = 1

                    camera.exit()
            except Exception as e:
                app.logger.debug(f'Unknown camera POST error: {e}')

    elif 'cameraUsbToggled' in request.form:
        # To get to here 'enableCameraUsb' must be false and 'cameraUsbToggled' is true, so this only fires if USB mode just just been disabled:
        app.logger.debug('camera page POSTed that the USB on/off checkbox has been toggled')
        setIni('Global', 'enableCameraUsb', 'False')
        cache.delete('enableCameraUsb')
        cache.set('enableCameraUsb', False, timeout = 300)

    return redirect(url_for('camera', preview = preview))


@app.route("/intervalometer")
@login_required
def intervalometer():
    """
    This page is where you manage all the interval settings for the Arduino
    """
    templateData = {
        'piDoW'            : '',
        'piStartHour'      : '',
        'piEndHour'        : '',
        'piInterval'       : '',
        'availableShots'   : 'Unknown',
        'piAvailableShots' : 'Unknown',
        'daysFreeWarn'     : '0',
        'daysFreeAlarm'    : '0'
    }
    app.logger.debug('This is a GET to Intervalometer')

    # Camera comms:
    try:
        camera, context, config, discardMe = connectCamera(1)
        if camera:
            #Find the capturetarget config item. (TY Jim.)
            capture_target = gp.check_result(gp.gp_widget_get_child_by_name(config, 'capturetarget'))
            currentTarget = gp.check_result(gp.gp_widget_get_value(capture_target))
            #app.logger.debug(f'Current captureTarget =  {currentTarget}')
            if currentTarget == "Internal RAM":
                #Change it to "Memory Card"
                try:
                    newTarget = 1
                    newTarget = gp.check_result(gp.gp_widget_get_choice(capture_target, newTarget))
                    gp.check_result(gp.gp_widget_set_value(capture_target, newTarget))
                    gp.check_result(gp.gp_camera_set_config(camera, config))
                    config = camera.get_config(context) #Refresh the config data for the availableshots to be read below
                    app.logger.debug('Set captureTarget to "Memory Card" in /intervalometer')
                except gp.GPhoto2Error as e:
                    app.logger.debug(f'GPhoto camera error setting capturetarget in /intervalometer: {e}')
                except Exception as e:
                    app.logger.debug(f'Unknown camera error setting capturetarget in /intervalometer: {e}')
            templateData['availableShots'] = readValue (config, 'availableshots')
            camera.exit()
    except Exception as e:
        app.logger.debug(f'Unknown camera error in intervalometer: {e}')

    ArdInterval = str(readFromArduino("3", "String", True))
    #Returns a string that's <DAY> (a byte to be treated as a bit array of days) followed by 2-digit strings of <startHour>, <endHour> & <Interval>:
    app.logger.debug(f'Int query returned: {ArdInterval}')
    if (ArdInterval != "Unknown") & (len(ArdInterval) == 7):
        for bit in range(1,8): # i.e. 1-7 inclusive
            if (ord(ArdInterval[0]) & (0b00000001<<bit)):
                app.logger.debug(f'Added {arduinoDoW[bit]}')
                templateData['piDoW'] += arduinoDoW[bit]   #Crude but effective: no need for csv niceties with this one
        templateData['piStartHour'] = ArdInterval[1:3]
        templateData['piEndHour'] = ArdInterval[3:5]
        templateData['piInterval'] = ArdInterval[5:7]
        app.logger.debug(f'Decoded Interval = {ArdInterval[5:7]}')

    _,piBytesFree = getDiskSpace()
    largestImageSize = getLargestImageSize(PI_PHOTO_DIR)
    templateData['piAvailableShots'] = str(round(piBytesFree / largestImageSize))
    templateData['daysFreeWarn']  = int(getIni('Thresholds', 'daysfreewarn', 'int', '14'))
    templateData['daysFreeAlarm']  = int(getIni('Thresholds', 'daysfreealarm', 'int', '7'))

    arduinoVersion = str(getArduinoVersion('0'))
    if version.parse(arduinoVersion) >=  version.parse("4.6.0"):
        templateData.update({'shootFast' : 1})

    return render_template('intervalometer.html', **templateData)


@app.route("/intervalometer", methods = ['POST'])    # The intervalometer's POST method
@login_required
def intervalometerPOST():
    """
    This page is where you manage all the interval settings for the Arduino
    """
    newInterval = ""
    shootDays = 0
    shootDaysList = request.form.getlist('shootDays')
    startHour = str(request.form.get('startHour'))
    endHour   = str(request.form.get('endHour'))
    interval  = '{:0>2}'.format(str(request.form.get('interval'))) #"Padright" : https://docs.python.org/2/library/string.html#formatstrings

    if (len(shootDaysList) != 0) & (startHour != 'None') & (endHour != 'None') & (interval != 'None'):
        for day in shootDaysList:
            bit = (time.strptime(day, "%A").tm_wday) + 2
            if (bit >= 8):
                bit = 1   #Correct for Python days starting with Monday = 0
            shootDays |= (1<<bit)   #Set the bit that corresponds to the named weekday
        app.logger.debug('Shoot days =  {:b}'.format(shootDays))
        newInterval += chr(shootDays)
        newInterval += startHour
        newInterval += endHour
        newInterval += interval
        writeString(f'SI={newInterval}', 1)    # Send the new interval data to the Arduino
        cache.delete("3")                      # Flush the previously cached value
        app.logger.debug(f'Detected a valid POST. Updated the interval to {newInterval}')
    else:
        app.logger.debug('Detected an *invalid* POST')
        flash('Invalid data posted to the page', 'red')
    return redirect(url_for('intervalometer'))


@app.route("/transfer")
@login_required
def transfer():
    """
    This page is where you manage how the images make it from the camera to the real world
    """
    if not os.path.isfile(iniFile):
        createConfigFile(iniFile)
    # Initialise the dictionary:
    templateData = {
        'tfrMethod'             : 'Off',    # Hides all options if the file isn't found or is bad
        'ftpServer'             : '',
        'ftpUser'               : '',
        'ftpPassword'           : '',
        'ftpRemoteFolder'       : '',
        'sftpServer'            : '',
        'sftpUser'              : '',
        'sftpPassword'          : '',
        'sftpRemoteFolder'      : '',
        'dbx_app_key'           : '',
        'rsyncUsername'         : '',
        'rsyncHost'             : '',
        'rsyncRemoteFolder'     : '',
        'transferDay'           : '',
        'transferHour'          : '',
        'copyDay'               : '',
        'copyHour'              : '',
        'wakePiTime'            : '25',
        'piTransferLogLink'     : '',
        'hiddenTransferOptions' : hiddenTransferOptions,
        'renameOnCopy'          : 'Off',
        'renameString'          : '',
        'copyOnBootup'          : '',
        'transferOnBootup'      : '',
        'cameraUsbMode'         : 'false' # Jinja requires bools in lower case
    }
    config = configparser.ConfigParser(
        {
        'tfrmethod'          : 'Off',
        'ftpServer'          : '',
        'ftpUser'            : '',
        'ftpPassword'        : '',
        'ftpRemoteFolder'    : '',
        'sftpServer'         : '',
        'sftpUser'           : '',
        'sftpPassword'       : '',
        'sftpRemoteFolder'   : '',
        'dbx_app_key'        : '',
        'rsyncUsername'      : '',
        'rsyncHost'          : '',
        'rsyncRemoteFolder'  : '',
        'transferDay'        : '',
        'transferHour'       : '',
        'copyDay'            : 'Off',
        'copyHour'           : '',
        'wakePiTime'         : '25',
        'renameOnCopy'       : 'Off',
        'renameString'       : '',
        'copyOnBootup'       : 'Off',
        'transferOnBootup'   : 'Off'
        })

    usbMode = getCameraUsbMode()
    templateData['cameraUsbMode'] = str(usbMode).lower() # jinja requires true/false as a lower-case string
    if usbMode:
        try:
            config.read(iniFile)
            #app.logger.debug('Found the file in transfer GET')
            templateData['tfrMethod']          = config.get('Transfer', 'tfrmethod')
            templateData['ftpServer']          = config.get('Transfer', 'ftpServer')
            templateData['ftpUser']            = config.get('Transfer', 'ftpUser')
            templateData['ftpPassword']        = config.get('Transfer', 'ftpPassword')
            templateData['ftpRemoteFolder']    = config.get('Transfer', 'ftpRemoteFolder')
            templateData['sftpServer']         = config.get('Transfer', 'sftpServer')
            templateData['sftpUser']           = config.get('Transfer', 'sftpUser')
            templateData['sftpPassword']       = config.get('Transfer', 'sftpPassword')
            templateData['sftpRemoteFolder']   = config.get('Transfer', 'sftpRemoteFolder')
            templateData['dbx_app_key']        = config.get('Transfer', 'dbx_app_key')
            templateData['rsyncUsername']      = config.get('Transfer', 'rsyncUsername')
            templateData['rsyncHost']          = config.get('Transfer', 'rsyncHost')
            templateData['rsyncRemoteFolder']  = config.get('Transfer', 'rsyncRemoteFolder')
            templateData['transferDay']        = config.get('Transfer', 'transferDay')
            templateData['transferHour']       = config.get('Transfer', 'transferHour')
            templateData['transferOnBootup']   = config.get('Transfer', 'transferOnBootup')
            templateData['copyDay']            = config.get('Copy', 'copyDay')
            templateData['copyHour']           = config.get('Copy', 'copyHour')
            templateData['renameOnCopy']       = config.get('Copy', 'renameOnCopy')
            templateData['renameString']       = config.get('Copy', 'renameString')
            templateData['copyOnBootup']       = config.get('Copy', 'copyOnBootup')
        except Exception as e:
            app.logger.debug(f'INI file error: {e}')
            flash('Error reading from the Ini file', 'red')

        templateData['piTransferLogLink'] = PI_TRANSFER_FILE.replace(PI_TRANSFER_DIR,'static')

        rawWakePi = str(readFromArduino("5", "String", True))
        if rawWakePi != "Unknown":
            setIni('Global', 'wakePiHour', rawWakePi[0:2])
            templateData['wakePiTime']     = rawWakePi[0:2]

    return render_template('transfer.html', **templateData)

@app.route("/transfer", methods = ['POST'])    # The camera's POST method
@login_required
def transferPOST():
    """
    This page is where you manage how the images make it from the camera to the real world
    """
    if 'tfrClear' in request.form:
        try:
            with open(PI_TRANSFER_FILE, 'w') as piTransferLogfile:
                nowtime = datetime.now().strftime('%Y/%m/%d %H:%M:%S') #2019/09/08 13:06:03
                piTransferLogfile.write(f'{nowtime} STATUS: piTransfer.log cleared\r\n')
        except Exception as e:
            app.logger.debug(f'Exception clearing piTransfer.log: {e}')

    if 'tfrApply' in request.form:
        if not os.path.isfile(iniFile):
            createConfigFile(iniFile)
        config = configparser.ConfigParser()
        try:
            config.read(iniFile)
            if not config.has_section('Transfer'):
                config.add_section('Transfer')
            config.set('Transfer', 'tfrMethod', str(request.form.get('tfrMethod')))
            if (request.form.get('tfrMethod') == 'FTP'):
                config.set('Transfer', 'ftpServer', str(request.form.get('ftpServer').replace('ftp://','') or ''))
                config.set('Transfer', 'ftpUser', str(request.form.get('ftpUser') or ''))
                config.set('Transfer', 'ftpPassword', str(request.form.get('ftpPassword') or ''))
                ftpRemoteFolder = reformatSlashes(str(request.form.get('ftpRemoteFolder')))
                config.set('Transfer', 'ftpRemoteFolder', ftpRemoteFolder or '')
            elif (request.form.get('tfrMethod') == 'SFTP'):
                config.set('Transfer', 'sftpServer', str(request.form.get('sftpServer').replace('sftp://','') or ''))
                config.set('Transfer', 'sftpUser', str(request.form.get('sftpUser') or ''))
                config.set('Transfer', 'sftpPassword', str(request.form.get('sftpPassword') or ''))
                sftpRemoteFolder = reformatSlashes(str(request.form.get('sftpRemoteFolder')))
                config.set('Transfer', 'sftpRemoteFolder', sftpRemoteFolder or '')
            elif (request.form.get('tfrMethod') == 'Dropbox'):
                config.set('Transfer', 'dbx_app_key', str(request.form.get('dbx_app_key') or ''))
            elif (request.form.get('tfrMethod') == 'rsync'):
                config.set('Transfer', 'rsyncUsername', str(request.form.get('rsyncUsername') or ''))
                config.set('Transfer', 'rsyncHost', str(request.form.get('rsyncHost') or ''))
                rsyncRemoteFolder = reformatSlashes(str(request.form.get('rsyncRemoteFolder')))
                config.set('Transfer', 'rsyncRemoteFolder', rsyncRemoteFolder or '')
            if (request.form.get('tfrMethod') != 'Off'):
                config.set('Transfer', 'transferDay', str(request.form.get('transferDay') or ''))
                config.set('Transfer', 'transferHour', str(request.form.get('transferHour') or ''))
            if not config.has_section('Copy'):
                config.add_section('Copy')
            config.set('Copy', 'copyDay', str(request.form.get('copyDay') or ''))
            config.set('Copy', 'copyHour', str(request.form.get('copyHour') or ''))
            config.set('Copy', 'renameOnCopy', str(request.form.get('renameOnCopy') or 'Off'))
            config.set('Copy', 'renameString', str(request.form.get('renameString').replace('%','%%') or ''))
            config.set('Copy', 'copyOnBootup', str(request.form.get('copyOnBootup') or 'Off'))
            config.set('Transfer', 'transferOnBootup', str(request.form.get('transferOnBootup') or 'Off'))
            with open(iniFile, 'w') as config_file:
                config.write(config_file)
        except Exception as e:
            app.logger.debug(f'INI file error writing: {e}')
            if 'Permission denied' in str(e):
                flash('Permission denied writing to the ini file', 'red')
            else:
                flash('Error writing to the Ini file', 'red')

    return redirect(url_for('transfer'))


@app.route("/copyNow")
def copyNowCronJob():
    """
    This 'page' is only one of three called without the "@login_required" decorator. It's only called by
    the cron job/cameraTransfer.py script and will only execute if the calling IP is itself/localhost.
    """
    sourceIp = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    if sourceIp != "127.0.0.1":
        abort(403)

    if getCameraUsbMode():
        tasks = [copyNow.si()]
        if (getIni('Transfer', 'transferDay', 'string', '') == 'afterCopy'):
            tasks.append(transferNow.si())
            app.logger.debug('copyNowCronJob() entered. A transfer will occur after the copy')
        tasks.append(newThumbs.si())
        chain(*tasks).apply_async()
    else:
        app.logger.debug('copyNowCronJob() entered, however CameraUsbMode is False. Aborting')

    res = make_response('OK')
    return res, 200


@app.route('/trnTrNow', methods=['POST'])
@login_required
def trnTransferNow():
    """
    This page is called in the background by the 'Transfer now' button on the Transfer page.
    It kicks off the background task, and returns the taskID so its progress can be followed
    """
    app.logger.debug('trnTransferNow() entered. [See /var/log/celery/celery_worker.log for what happens here]')

    tasks = [
        transferNow.si()
    ]
    task = chain(*tasks).apply_async()

    app.logger.debug(f'trnTransferNow() returned with task_id= {task.id}')
    return jsonify({}), 202, {'Location': url_for('backgroundStatus', task_id=task.id)}


@celery.task(time_limit=1800, bind=True)
def transferNow(self):
    app.logger.info('TransferNow() entered') #This logs to /var/log/celery/celery_worker.log
    self.update_state(state='PROGRESS', meta={'status': 'Preparing to transfer images', 'statusColour': 'white'})
    errorMsg = 'out'
    statusColour = 'white'
    try:
        #cmd = ['sudo', '/bin/systemctl', 'start', 'piTransfer'] # Removed with 4.6.3 in March 2024.
        cmd = ['sudo', '/usr/bin/python3', 'piTransfer.py', 'copyNow']
        result = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, encoding='utf-8')
        (stdoutdata, stderrdata) = result.communicate()
        if stdoutdata:
            stdoutdata = stdoutdata.strip()
            app.logger.info(f'transferNow output text = {stdoutdata}')
        if stderrdata:
            stderrdata = stderrdata.strip()
            app.logger.info(f'transferNow error = {stderrdata}')
            errorMsg = ''
    except Exception as e:
        app.logger.info(f'Unhandled transferNow error: {e}')
        errorMsg = ' unexpected'

    if errorMsg != 'out':
        statusColour = 'red'
    statusMessage = (f'transferNow returned with{errorMsg} error')
    return {'status': statusMessage, 'statusColour': statusColour}


@app.route("/thermal")
@login_required
def thermal():
    """
    This page is where you monitor and manage the thermal settings & alarms
    """
    templateData = {
        'thermalUnits'   : "Celsius",
        'arduinoTemp'    : 'Unknown',
        'arduinoMin'     : 'Unknown',
        'arduinoMax'     : 'Unknown',
        'piTemp'         : 'Unknown',
        'dayTempMax'     : '- ',
        'dayTempMaxAt'   : '',
        'dayTempMin'     : '- ',
        'dayTempMinAt'   : '',
        'dayTempMaxScale': 80,
        'dayTempMinScale': -40,
        'freezing'       : 0,
        'vMax'           : 'Unknown',
        'vMaxAt'         : '',
        'vMin'           : 'Unknown',
        'vMinAt'         : '',
        'VHiAlarm'       : 0,
        'VLoAlarm'       : 0,
        'vFSD'           : 18 #A constant to feed to the page & use for valculations
        }

    thermalUnits = request.cookies.get('thermalUnits')
    if thermalUnits == 'Fahrenheit' :
        templateData['thermalUnits'] = "Fahrenheit"
        templateData['freezing'] = 32
        freezing = 32
    else:
        thermalUnits = 'Celsius'   # Just in case the cookie doesn't exist.
        templateData['freezing'] = 0
        freezing = 0

    try:
        writeString("GT", 2) # Asks the Arduino to update its temperature string
        temperatures = str(readFromArduino("4", "String", False)) # Reads the resulting string, a csv array
        if 'Unknown' not in temperatures:
            templateData['arduinoTemp'] = temperatures.split(",")[0]
            templateData['arduinoMin']  = temperatures.split(",")[2]
            templateData['arduinoMax']  = temperatures.split(",")[1]
    except Exception as e:
        app.logger.debug(f'GT exception in /thermal: {e}')
    templateData['piTemp'] = getPiTemp()

    arduinoVersion = str(getArduinoVersion('0'))
    # Start Temps24
    if version.parse(arduinoVersion) >=  version.parse(SHOW_TEMPS24):
        time.sleep(0.1)
        Temps24 = []
        try:
            temperatures = readFromArduino("7", "Binary", False) # Reads 24 hours' worth of temp's as 24 bytes of binary data
            app.logger.info(f'Type of temperatures is {type(temperatures)}')
            app.logger.info(f'Type of temperatures[0] is {type(temperatures[0])} and value = {temperatures[0]}')
            dayTempMax = -128
            dayTempMaxAt = 0
            dayTempMin =  127
            dayTempMinAt = 0
            for i in range(24):
                value = int.from_bytes((temperatures[i]).to_bytes(1, byteorder='little'), 'little', signed=True)
                app.logger.info(f'Temp at {i} = {value} degrees')
                Temps24.append({'hour' : str(i), 'temp' : convertTemp(value, thermalUnits)})
                if value > dayTempMax:
                    dayTempMax = value
                    dayTempMaxAt = i
                if value < dayTempMin:
                    dayTempMin = value
                    dayTempMinAt = i
            templateData['dayTempMaxAt'] = dayTempMaxAt
            templateData['dayTempMinAt'] = dayTempMinAt
            templateData['dayTempMax']      = str(dayTempMax) # C/F conversion happens in the page
            templateData['dayTempMin']      = str(dayTempMin) # Here I'm stamping the ACTUAL Min to the page for the table, but
                                                              # next I adjust it for "freezing", to set dayTempMinScale
            if dayTempMin > freezing:
                dayTempMin = freezing # Reset to 'freezing' for positive-days to ensure the scale is zero-referenced
            dayTempMin = convertTemp(dayTempMin, thermalUnits)
            dayTempMax = convertTemp(dayTempMax, thermalUnits)
            dayTempMinScale = math.floor(dayTempMin/5)*5;                   # Rounds Min temp to nearest 5 so the table can auto-scale
            dayTempMaxScale = max((freezing+10),math.ceil(dayTempMax/5)*5); # Rounds Max temp to nearest 5 so the table can auto-scale
                                                                            # Wrapping in 'max' constrains lower result to a minimum positive excursion of 10 degrees,
                                                                            # and also prevents a /0 error if the Arduino doesn't respond as expected.
            # The graticule needs to step in 2's and 7's if F, not 0's and 5's:
            if 'Fahrenheit' in thermalUnits:
                if dayTempMinScale < 0:
                    if dayTempMin >= (dayTempMinScale + 2):
                        dayTempMinScale += 2
                    else:
                        dayTempMinScale -= 3
                else:
                    if dayTempMin >= (dayTempMinScale + 2):
                        dayTempMinScale += 2
                    else:
                        dayTempMinScale -= 3
                if dayTempMaxScale >= 0:
                    if dayTempMax >= (dayTempMaxScale - 3):
                        dayTempMaxScale += 2
                    else:
                        dayTempMaxScale -= 3
                else:
                    if dayTempMax >= (dayTempMaxScale + 3):
                        dayTempMaxScale -= 2
                    else:
                        dayTempMaxScale += 3
            if dayTempMinScale > freezing:
                dayTempMinScale = freezing
            templateData['dayTempMaxScale'] = dayTempMaxScale
            templateData['dayTempMinScale'] = dayTempMinScale

            app.logger.info(f'Freezing = {freezing}, dayTempMaxScale / dayTempMinScale = {dayTempMaxScale} / {dayTempMinScale}')

        except Exception as e:
            app.logger.debug(f'Temps24 exception in /thermal: {e}')
            for i in range(24):
                Temps24.append({'hour' : str(i), 'temp' : freezing })
        templateData.update({'Temps24' : Temps24})
    else:
        app.logger.debug(f'Arduino version is too old for Temps24 display in /thermal')
    # End Temps24
    # ---------------------------------------------------------------
    # Start Volts24
    try:
        if version.parse(arduinoVersion) >=  version.parse(SHOW_VOLTS24):
            batteryVoltageArray = readFromArduino("8", "String", False)  # All 24 voltage readings (offset by 10) as a string of bytes
            voltageReadings = []                        # A list that stores all 24 voltage readings for the page to render
            if (ord(batteryVoltageArray[0]) != 255) and (len(batteryVoltageArray) == 24):
                # It appears formatted correctly?? Loop through to decode, correct and capture max/min values
                app.logger.info("Voltage array is GOOD")
                vMax = 0
                vMaxAt = 0
                vMin = 180
                vMinAt = 0
                for i in range(24):
                    thisHour = ord(batteryVoltageArray[i]) - 10
                    #app.logger.info('Battery voltage at {0} = {1}V'.format(i, thisHour))
                    voltageReadings.append({'hour' : str(i), 'voltage' : '{0:.1f}'.format(float(thisHour)/10) })
                    if thisHour == 0:
                        continue # "0V" is invalid / should not happen. Exclude from max/min calc's
                    if thisHour > vMax:
                        vMax = thisHour
                        vMaxAt = i
                    if thisHour < vMin:
                        vMin = thisHour
                        vMinAt = i
                templateData['vMax']   = '{0:.1f}'.format(float(vMax)/10)
                templateData['vMaxAt'] = vMaxAt
                templateData['vMin']   = '{0:.1f}'.format(float(vMin)/10)
                templateData['vMinAt'] = vMinAt
            else:
                app.logger.info("Voltage array is BAD - or absent")
                for i in range(24):
                    voltageReadings.append({'hour' : str(i), 'voltage' : '0'})
            templateData.update({'voltageReadings' : voltageReadings})
            templateData['VHiAlarm'] = int(getIni('Thresholds', 'voltage_high', 'int', '14'))
            templateData['VLoAlarm'] = int(getIni('Thresholds', 'voltage_low', 'int', '9'))
    except Exception as e:
        app.logger.debug(f'Volts24 exception in /thermal: {e}')
    # End volts24

    return render_template('thermal.html', **templateData)


def convertTemp(temperature, units):
    if "Celsius" in units: return temperature
    return (int(round((temperature) * 9/5) + 32))


@app.route("/thermal", methods = ['POST'])    # The thermal page's POST method
@login_required
def thermalPOST():
    """
    This page is where we act on the Reset buttons for max/min temp
    """
    res = make_response("")

    if request.form.get('thermalUnits') == 'Celsius':
        res.set_cookie('thermalUnits', 'Celsius', 7 * 24 * 60 * 60)
    else:
        res.set_cookie('thermalUnits', 'Fahrenheit', 7 * 24 * 60 * 60)

    if 'resetMin' in request.form:
        app.logger.debug('thermal sent RN')
        writeString("RN", 1) # Sends the Reset Min command to the Arduino
    if 'resetMax' in request.form:
        app.logger.debug('thermal sent RX')
        writeString("RX", 1) # Sends the Reset Max command to the Arduino

    res.headers['location'] = url_for('thermal')
    return res, 302


@app.route("/monitoring")
@login_required
def monitoring():
    """
    Monitoring is where the heartbeating is setup
    TY Christian David for the URL validation: https://stackoverflow.com/questions/8667070/javascript-regular-expression-to-validate-url
    """
    templateData = {
        'hbUrl'  : '',
        'hbFreq' : '',
        'hbResult' : 'None'
        }
    templateData['hbUrl']  = getIni('Monitoring', 'heartbeatUrl', 'string', '')
    templateData['hbFreq'] = getIni('Monitoring', 'heartbeatFrequency', 'string', 'Off')

    try:
        with open(PI_HBRESULT_FILE, 'r') as f:
            hbResult = f.readline()
            if hbResult:
                templateData['hbResult'] = hbResult
    except Exception as e:
        app.logger.debug(f'Exception reading PI_HBRESULT_FILE in /monitoring: {e}')

    return render_template('monitoring.html', **templateData)


@app.route("/monitoring", methods = ['POST'])    # The monitoring page's POST method
@login_required
def monitoringPOST():
    """
    This page is where changes to the Monitoring page are actioned
    """
    if 'monApply' in request.form:
        if not os.path.isfile(iniFile):
            createConfigFile(iniFile)
        config = configparser.ConfigParser()
        try:
            config.read(iniFile)
            if not config.has_section('Monitoring'):
                config.add_section('Monitoring')
            config.set('Monitoring', 'heartbeatfrequency', str(request.form.get('hbFreq')))
            config.set('Monitoring', 'heartbeaturl', str(request.form.get('hbUrl')))
            with open(iniFile, 'w') as config_file:
                config.write(config_file)
        except Exception as e:
            app.logger.debug(f'mon INI file error writing: {e}')
            if 'Permission denied' in str(e):
                flash('Permission denied writing to the ini file', 'red')
            else:
                flash('Error writing to the Ini file', 'red')

    return redirect(url_for('monitoring'))


@app.route('/monHbNow', methods=['POST'])
@login_required
def monHbNow():
    """
    This page is called in the background by the 'Heartbeat now' button on the Remote Monitoring page
    It kicks off the background task, and returns the taskID so its progress can be followed
    """
    app.logger.debug('monHbNow() entered. [See /var/log/celery/celery_worker.log for what happens here]')

    tasks = [
        initiateHeartbeat.si()
    ]
    task = chain(*tasks).apply_async()

    app.logger.debug(f'monHbNow returned with task_id= {task.id}')
    return jsonify({}), 202, {'Location': url_for('backgroundStatus', task_id=task.id)}


@app.route("/heartbeat")
def heartbeatCronJob():
    """
    This 'page' does not have the "@login_required" decorator. It's only called by
    the systemd service / heartbeat.py script and will only execute if the calling IP is itself/localhost.
    """
    sourceIp = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    if sourceIp != "127.0.0.1":
        abort(403)

    tasks = [
        initiateHeartbeat.si()
    ]
    chain(*tasks).apply_async()

    #Make two attempts at heartbeating:
    for i in range(2):
        task = chain(*tasks).apply_async()
        result = task.wait(timeout=20, interval=1)
        app.logger.debug(f'heartbeatCronJob {i + 1}/2 reported result = {result}')
        if int(result['statusCode']) // 100 == 2:
            #It's a success message, in the 2xx range.
            break
    res = make_response('OK') # We return OK to the calling script regardless, confirmating that intvlm8r.py responded.
    return res, 200


@celery.task(time_limit=60, bind=True)
def initiateHeartbeat(self):
    """
    This fn pings the heartbeat URL and logs the result to the 'hbResult' file
    """
    self.update_state(state='PROGRESS', meta={'status': 'Initiating heartbeat', 'statusColour': 'white'})
    url = getIni('Monitoring', 'heartbeatUrl', 'string', None)
    resultText = 'Error'
    statusMessage = 'Unknown error'
    statusColour = 'red'
    statusCode = 0
    if url:
        response   = None
        htmltext   = None
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status() #Throws a HTTPError if we didn't receive a 2xx response
            htmltext = response.text.rstrip()
            statusCode = response.status_code
            app.logger.debug(f'Status code = {statusCode}')
            app.logger.debug(f'This is what I received: {htmltext}')
        except requests.exceptions.Timeout as e:
            app.logger.debug(f'initiateHeartbeat Timeout error: {e}')
            briefErrMsg = 'Timeout error'
        except requests.exceptions.ConnectionError as e:
            app.logger.debug(f'initiateHeartbeat ConnectionError: {e}')
            briefErrMsg = 'Conn. error'
        except requests.exceptions.HTTPError as e:
            app.logger.debug(f'initiateHeartbeat HTTPError: {e}')
            briefErrMsg = 'HTTP error {0}'.format(e.response.status_code)
        except requests.exceptions.TooManyRedirects as e:
            app.logger.debug(f'initiateHeartbeat TooManyRedirects error: {e}')
            briefErrMsg = 'Redir error'
        except Exception as e:
            app.logger.debug(f'initiateHeartbeat Unhandled web error: {e}')
            briefErrMsg = 'Unknown error'
        try:
            with open(PI_HBRESULT_FILE, 'w') as resultFile:
                nowtime = datetime.now().strftime('%Y/%m/%d %H:%M:%S') #2019/09/08 13:06:03
                if statusCode:
                    resultFile.write(f'{nowtime} ({statusCode})')
                    statusMessage = (f'Heartbeat reported success ({statusCode})')
                    statusColour = 'white'
                else:
                    resultFile.write(f'{nowtime} ({briefErrMsg})')
                    statusMessage = (f'Heartbeat reported failure: ({briefErrMsg})')
        except Exception as e:
            app.logger.debug(f'initiateHeartbeat resultfile exception: {e}')
    else:
        app.logger.debug('initiateHeartbeat exited. No heartbeatUrl')
        statusMessage = 'Error: no heartbeat url'
    return {'status': statusMessage, 'statusColour': statusColour, 'statusCode': statusCode}


@app.route("/system")
@login_required
def system():

    templateData = {
        'piThumbCount'        : '24',
        'arduinoDate'         : 'Unknown',
        'arduinoTime'         : '',
        'piDateTime'          : 'Unknown',
        'piTimezone'          : 'Unknown',
        'piNtp'               : '',
        'piHostname'          : 'Unknown',
        'piUptime'            : 'Unknown',
        'piModel'             : 'Unknown',
        'piLinuxVer'          : 'Unknown',
        'piBitness'           : 'Unknown',
        'piSpaceFree'         : 'Unknown',
        'wakePiTime'          : '',
        'wakePiDuration'      : '',
        'rebootSafeWord'      : REBOOT_SAFE_WORD,
        'intvlm8rVersion'     : 'Unknown',
        'arduinoVersion'      : 'Unknown',
        'libgphoto2Version'   : 'Unknown',
        'pythonGphoto2Version': 'Unknown',
        'cameraDateTime'      : 'Unknown',
        'tzOffset'            : '0',
        'cameraTimeMode'      : 0,
        'timeSettingOptions'  : TIME_SETTING_OPTIONS,
        'timeSettingsValid'   : 0,
        'cameraUsbMode'       : 'false' # Jinja requires bools in lower case
        }

    templateData['piThumbCount'] = getIni('Global', 'thumbsCount', 'int', '24')

    camera, context, config, usbMode = connectCamera(4) # Check the camera: see if it's awake, and if not, just wake it and return
    templateData['cameraUsbMode'] = usbMode

    arduinoVersion = str(getArduinoVersion('0'))

    try:
        with open('/proc/device-tree/model', 'r') as myfile:
            templateData['piModel'] = myfile.read()
    except Exception as e:
        app.logger.debug(f'system: Threw querying PiModel: {e}')

    try:
        with open("/etc/os-release") as f:
            release_info = dict()
            for line in f:
                key, value = line.rstrip().split("=")
                release_info[key] = value.strip('"')
                templateData['piLinuxVer'] = release_info["PRETTY_NAME"]
    except Exception as e:
        app.logger.debug(f'system: Threw querying Pi os version: {e}')

    try:
        arduinoDate = getArduinoDate() # Failure returns "Unknown"
        tempTime = getArduinoTime()    # Failure returns "", on-screen as "Unknown", but *might* also report midnight in the absence of a working RTC!
        templateData['arduinoDate'] = arduinoDate
        if arduinoDate != 'Unknown':
            templateData['arduinoTime'] = tempTime
        rawWakePi = str(readFromArduino("5", "String", False))
        if rawWakePi != "Unknown":
            wakePiTime                     = rawWakePi[0:2]
            templateData['wakePiTime']     = wakePiTime
            templateData['wakePiDuration'] = rawWakePi [2:4]
            if wakePiTime != "25":
                if version.parse(arduinoVersion) >=  version.parse(SHOW_SHUTDOWN_IN):
                    shutdownAt = int(readFromArduino("9", "String", False)) # The Arduino returns the minute past the hour that it will shutdown
                    if 0 <= shutdownAt <= 119:
                        if tempTime != '':
                            shutdownAt -= 1  #Remove the bonus minute added in the Arduino. This prevents on-screen confusion when time remaining is 1 minute > the value you just set.
                            shutdownAt = shutdownAt - int(tempTime.split(":")[1])
                            templateData['piShutdownIn'] = shutdownAt
                        else:
                            templateData['piShutdownIn'] = 'Unknown'
                    else:
                        templateData['piShutdownIn'] = 'Unknown'
    except Exception as e:
        app.logger.debug(f'system: Threw querying Arduino DateTime: {e}')

    templateData['piDateTime'] = datetime.now().strftime('%Y %b %d %H:%M:%S') #2019 Mar 08 13:06:03
    templateData['piTimezone'] = datetime.now().astimezone().tzname()
    templateData['piNtp'] = checkNTP(None)

    try:
        if (sys.maxsize > 2**32):
            templateData['piBitness']   = '64'
        else:
            templateData['piBitness']   = '32'
        templateData['piUptime']    = getPiUptime()
        templateData['piHostname']  = HOSTNAME
        templateData['piSpaceFree'],_ = getDiskSpace()
    except Exception as e:
        app.logger.debug(f'system: Threw querying Pi details: {e}')

    try:
        with open('version', 'r') as versionFile:
            templateData['intvlm8rVersion']   = versionFile.read()
        templateData['libgphoto2Version']     = gp.gp_library_version(gp.GP_VERSION_SHORT)[0]
        templateData['pythonGphoto2Version'] = gp.__version__
    except Exception as e:
        app.logger.debug(f'system: Unexpected error querying version info: {e}')

    templateData['arduinoVersion'] = 'Unknown' if (str(arduinoVersion) == '0') else str(arduinoVersion)

    if usbMode == "true":
        try:
            if not config:
                camera, context, config, discardMe = connectCamera(1)
            if camera:
                templateData['cameraDateTime'] = getCameraTimeAndDate(camera, config, 'Unknown')

                #Capture all the valid time setting options:
                timeSettingsValid = 0
                for value, name in TIME_SETTING_OPTIONS:
                    if readValue(config,name) != 'Not available':
                        timeSettingsValid += value
                templateData['timeSettingsValid'] = timeSettingsValid
                app.logger.debug(f'system: timeSettingsValid = {timeSettingsValid}')
                camera.exit()
        except Exception as e:
            app.logger.debug(f'system: Threw in cameraDateTime: {e}')

    try:
        tzOffset = (request.cookies.get('tzOffset'))
        app.logger.debug(f'system: tzOffset cookie = {tzOffset}')
        if tzOffset == None or (not (all(ch in '1234567890-.' for ch in tzOffset))):
            app.logger.debug(f'system: None or bad cookie: {tzOffset}')
            templateData['tzOffset'] = '0'
        else:
            templateData['tzOffset'] = tzOffset
    except:
        templateData['tzOffset'] = '0'
        app.logger.debug(f'system: Threw on bad Tz cookie: {tzOffset}')

    try:
        cameraTimeMode = request.cookies.get('cameraTimeMode')
    except:
        cameraTimeMode = '0'
        app.logger.debug(f'system: Threw on bad cameraTimeMode: {cameraTimeMode}')
    templateData['cameraTimeMode'] = cameraTimeMode

    return render_template('system.html', **templateData)


@app.route("/system", methods = ['POST'])    # The system page's POST method
@login_required
def systemPOST():

    app.logger.debug('This is the /system POST page')
    res = make_response("")

    if 'submitLocation' in request.form:
        try:
            newName = str(request.form.get('newName'))
            if newName != None:
                cache.set('locationName', newName, timeout = 0)
                app.logger.debug(f'New loc set as {newName}')
                setIni('Global', 'locationName', newName)
        except:
            app.logger.debug('Location set error')

    if 'submitThumbsCount' in request.form:
        try:
            newCount = str(request.form.get('thumbsCount'))
            if newCount != None:
                app.logger.debug(f'New thumbs count set as {newCount}')
                setIni('Global', 'thumbsCount', newCount)
        except Exception as e:
            app.logger.debug(f'New Thumbs set error: {e}')

    if 'wakePi' in request.form:
        app.logger.debug(f"Yes we got the WAKE PI button & values {request.form.get('wakePiTime')}, {request.form.get('wakePiDuration')}")
        WakePiHour = str(request.form.get('wakePiTime'))
        if WakePiHour == 'Always On':
            WakePiHour = '25'
        setIni('Global', 'wakePiHour', WakePiHour)
        writeString(f"SP={WakePiHour}{request.form.get('wakePiDuration')}", 1)
        cache.delete("5")   # Flush the previously cached value

    if 'extend' in request.form:
        app.logger.debug('Yes we got the EXTEND button')
        writeString('EX', 1)

    if 'SyncSystem' in request.form:
        newTime = str(request.form.get('SyncSystem'))
        cameraTimeMode = str(request.form.get('cameraTimeMode'))
        app.logger.debug(f'Yes we got the SyncSystem button & value {newTime}')
        if request.form.get('setArduinoTime'):
            app.logger.debug('Checked: setArduinoTime')
            writeString("ST=" + newTime, 1) # Send the new time and date to the Arduino
        if request.form.get('setPiTime'):
            app.logger.debug('Checked: setPiTime' )
            setTime(newTime)
        if request.form.get('setCameraTime'):
            app.logger.debug('Checked: setCameraTime')
            try:
                camera, context, config, discardMe = connectCamera(1)
                if camera:
                    if setCameraTimeAndDate(camera, config, newTime, cameraTimeMode):
                        # apply the changed config
                        camera.set_config(config)
                    else:
                        app.logger.debug('Failed to setCameraTimeAndDate')
                        flash('Error setting camera time & date', 'red')
                    camera.exit()
            except Exception as e:
                app.logger.debug(f'Exception trying to setCameraTimeAndDate: {e}')
        # Lastly here, let's set the cookies:
        res.set_cookie('tzOffset', request.form.get('tzOffsetValue'), 365 * 7 * 24 * 60 * 60)
        res.set_cookie('cameraTimeMode', cameraTimeMode, 365 * 7 * 24 * 60 * 60)

    if 'Reboot' in request.form:
        if str(request.form.get('rebootString')) == REBOOT_SAFE_WORD:
            writeString("RA", 1)
            #app.logger.debug(f'Yes we got reboot safe word - {REBOOT_SAFE_WORD}')
        else:
            pass
            #app.logger.debug(f'Button pressed but no reboot safe word - {REBOOT_SAFE_WORD}')

    res.headers['location'] = url_for('system')
    return res, 302


def checkNTP(returnValue):
    try:
        cmd = ['/bin/systemctl', 'is-active', 'systemd-timesyncd']
        result = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, encoding='utf-8')
        (stdoutdata, stderrdata) = result.communicate()
        if stdoutdata:
            stdoutdata = stdoutdata.strip()
            if stdoutdata == 'active':
                app.logger.info(f'systemd-timesyncd = {stdoutdata}. The Pi takes its time from NTP')
                returnValue = True
            else:
                app.logger.info(f'systemd-timesyncd = {stdoutdata}. The Pi does NOT take its time from NTP')
        if stderrdata:
            stderrdata = stderrdata.strip()
            app.logger.debug(f'systemd-timesyncd error = {stderrdata}')
    except Exception as e:
        app.logger.debug(f'Unhandled systemd-timesyncd error: {e}')
    return returnValue


def setTime(newTime):
    """
    Takes the time passed from the user's PC and sets the Pi's real time clock
    """
    try:
        #convert it to a form the date command will accept: Incoming is "20181129215800" representing "2018 Nov 29 21:58:00"
        timeCommand = ['/bin/date', '--set=%s' % datetime.strptime(newTime,'%Y%m%d%H%M%S')]
        result = subprocess.Popen(timeCommand, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, encoding='utf-8')
        (stdoutdata, stderrdata) = result.communicate()
        if stdoutdata:
            stdoutdata = stdoutdata.strip()
            app.logger.debug(f'setTime result = {stdoutdata}')
        if stderrdata:
            stderrdata = stderrdata.strip()
            app.logger.debug(f'setTime error = {stderrdata}')
    except Exception as e:
        app.logger.debug(f'setTime unhandled time error: {e}')


def getCameraUsbMode():
    """
    Queries the cache to determine if Camera USB comms is enabled.
    If this fails to return a result, query the INI file.
    Still no hits? Default to True
    """
    result = cache.get('enableCameraUsb')
    if result is None:
        #The cache is empty? Read from INI, and set the cache
        app.logger.debug('getCameraUsbMode cache query returned None')
        result = getIni('Global', 'enableCameraUsb', 'bool', 'True')
        cache.set('enableCameraUsb', result, timeout = 300)
    return result


def connectCamera(retries):
    """
    Establishes a connection to the camera & returns a tuple of the camera objects.
    The 'retries' value lets the calling fn determine how much time we'll invest in trying to get the camera's attention.
    This is all done in an effort to minimise page load times
    """
    app.logger.debug('connectCamera entered')
    if getCameraUsbMode():
        try:
            camera = gp.Camera()
            context = gp.gp_context_new()
            while True:
                app.logger.debug(f'connectCamera retries = {retries}')
                try:
                    camera.init(context)
                    config = camera.get_config(context)
                    app.logger.debug('connectCamera has made a connection to the camera. Exiting')
                    break
                except gp.GPhoto2Error as e:
                    app.logger.debug(f'connectCamera GPhoto2Error: {e}')
                    if e.string == 'Unknown model':
                        if retries % 2 == 0:
                            app.logger.debug('connectCamera waking the camera & going again')
                            writeString("WC", 1) # Sends the WAKE command to the Arduino
                        else:
                            app.logger.debug('connectCamera going again without waking the camera')
                    elif e.string == 'Could not claim the USB device':
                        app.logger.debug('connectCamera could not claim the USB device. Exiting')
                        #TODO: pass this back upstream to present to the user
                        camera.exit()
                        return None, None, None, 'true'
                except Exception as e:
                    app.logger.debug(f'connectCamera error: {e}')
                if retries >= 4:
                    app.logger.debug('connectCamera returning None')
                    camera.exit()
                    return None, None, None, 'true'
                if retries % 2 == 0:
                    time.sleep(1.5);    # Pause after waking
                else:
                    time.sleep(0.5);  # Brief pause before looping
                retries += 1
            app.logger.debug('connectCamera returning 3 values')
            return camera, context, config, 'true'
        except Exception as e:
            app.logger.debug(f'connectCamera outer error: {e}')
            return None, None, None, 'true'
    else:
        app.logger.debug('connectCamera returned  - NO CAMERA MODE active')
        return None, None, None, 'false'


def readValue ( camera, attribute ):
    """
    Reads a simple attribute in the camera and returns the value
    """
    try:
        object = gp.check_result(gp.gp_widget_get_child_by_name(camera, attribute))
        value = gp.check_result(gp.gp_widget_get_value(object))
    except:
        value = 'Not available'
    return value


def readRange ( camera, group, attribute ):
    """
    Reads an attribute within a given group and returns the current setting and all the possible options
    It's only called by "camera" and "main" when we already have an established connection to the
    camera, so it's inappropriate (and inefficient) to attempt a reconnection here.
    """
    options = []
    currentValue = 'Unknown'
    try:
        config_tree = camera.get_config()
        total_child = config_tree.count_children()
        for i in range(total_child):
            child = config_tree.get_child(i)
            if (child.get_name() == group):
                for a in range(child.count_children()):
                    grandchild = child.get_child(a)
                    try:
                        if (grandchild.get_name() == attribute):
                            currentValue = grandchild.get_value()
                            if grandchild.get_type() == gp.GP_WIDGET_TEXT:
                                #This attribute is only text, there are no options. Return.
                                break
                            for k in range(grandchild.count_choices()):
                                choice = grandchild.get_choice(k)
                                options.append(choice)
                    except Exception as e:
                        app.logger.debug(f'Exception in readRange: {e}. Group/Attribute = {group}/{attribute}, currentValue = {currentValue}')
                        #break   #We have found and extracted the attribute we were seeking
    except Exception as e:
        app.logger.debug(f'readRange threw: {e}')
    return currentValue, options


def getCameraTimeAndDate( camera, config, returnValue ):
    try:
        # find the date/time setting config item and get it
        # name varies with camera driver
        #   Canon EOS350d - 'datetime'
        #   PTP - 'd034'
        for name, fmt in (('datetime', '%Y %b %d %H:%M:%S'),
                          ('datetimeutc', None),
                          ('d034',     None)):
            OK, datetime_config = gp.gp_widget_get_child_by_name(config, name)
            if OK >= gp.GP_OK:
                widget_type = gp.check_result(gp.gp_widget_get_type(datetime_config))
                if widget_type == gp.GP_WIDGET_DATE:
                    raw_value = gp.check_result(
                        gp.gp_widget_get_value(datetime_config))
                    returnValue = datetime.fromtimestamp(raw_value).strftime('%Y %b %d %H:%M:%S')
                else:
                    raw_value = gp.check_result(gp.gp_widget_get_value(datetime_config))
                    if fmt:
                        camera_time = datetime.strptime(raw_value, fmt)
                    else:
                        camera_time = datetime.utcfromtimestamp(float(raw_value))
                    returnValue = camera_time.isoformat(' ')
                break
    except Exception as e:
        app.logger.debug(f'Error reading camera time and date: {e}')
    return returnValue


def setCameraTimeAndDate(camera, config, newTimeDate, cameraTimeMode):
    """
    Based on Jim's example "set-camera-clock.py"
    """
    app.logger.debug(f'Entered setCameraTimeAndDate. cameraTimeMode = {cameraTimeMode}')
    for value, name in TIME_SETTING_OPTIONS:
        if value == int(cameraTimeMode):
            app.logger.debug(f'Setting camera time option {value}, {name}')
            break
    try:
        #abilities = camera.get_abilities()
        # These need to be carefully sequenced so you don't misfire on 'shorter' in 'longer':
        if 'syncdatetimeutc' in name:
            OK, sync_config = gp.gp_widget_get_child_by_name(config, 'syncdatetimeutc')
            if OK >= gp.GP_OK:
                sync_config.set_value(1)
            else:
                app.logger.debug("setCameraTimeAndDate didn't receive OK to syncdatetimeutc widget query")
                return False
            return True
        elif 'datetimeutc' in name:
            OK, date_config = gp.gp_widget_get_child_by_name(config, 'datetimeutc')
            if OK >= gp.GP_OK:
                now = int(time.time())
                date_config.set_value(now)
                return True
            else:
                app.logger.debug("setCameraTimeAndDate didn't receive OK to datetimeutc widget query")
                return False
        elif 'syncdatetime' in name:
            OK, sync_config = gp.gp_widget_get_child_by_name(config, 'syncdatetime')
            if OK >= gp.GP_OK:
                sync_config.set_value(1)
            else:
                app.logger.debug("setCameraTimeAndDate didn't receive OK to syncdatetime widget query")
                return False
            return True
        elif 'datetime' in name:
            OK, date_config = gp.gp_widget_get_child_by_name(config, 'datetime')
            if OK >= gp.GP_OK:
                widget_type = date_config.get_type()
                if widget_type == gp.GP_WIDGET_DATE:
                    app.logger.debug('setCameraTimeAndDate datetime as GP_WIDGET_DATE integer')
                    now = time.strptime(newTimeDate,'%Y%m%d%H%M%S')
                    epochTime = int(time.mktime(now))
                    app.logger.debug('epochTime = {0}'.format(epochTime))
                    date_config.set_value(epochTime)
                else:
                    app.logger.debug('setCameraTimeAndDate datetime as string')
                    now = time.strptime(newTimeDate,'%Y%m%d%H%M%S')
                    newNow = time.strftime('%Y-%m-%d %H:%M:%S', now)
                    date_config.set_value(newNow)
                return True
            else:
                app.logger.debug("setCameraTimeAndDate didn't receive OK to datetime widget query")
                return False
        else:
            app.logger.debug('setCameraTimeAndDate failed to match on the incoming cameraTimeMode')
            return False
    except Exception as e:
        app.logger.debug(f'setCameraTimeAndDate threw: {e}')
    return False


def list_camera_files(camera, path='/'):
    """
    Returns a list of all the image files on the camera
    """
    result = []
    # get files
    for name, value in gp.check_result(
            gp.gp_camera_folder_list_files(camera, path)):
        result.append(os.path.join(path, name))
    # read folders
    folders = []
    for name, value in gp.check_result(
            gp.gp_camera_folder_list_folders(camera, path)):
        folders.append(name)
    # recurse over subfolders
    for name in folders:
        result.extend(list_camera_files(camera, os.path.join(path, name)))
    return result


def list_Pi_Images(path):
    result = []
    for root, dirs, files in os.walk(os.path.expanduser(path)):
        for name in files:
            if '.thumbs' in dirs:
                dirs.remove('.thumbs')
            if name in ('.directory',):
                continue
            ext = os.path.splitext(name)[1].lower()
            if ext in ('.db',):
                continue
            if ext in ('.txt',):
                continue
            result.append(os.path.join(root, name))
    return result


def get_camera_file_info(camera, path):
    """
    Returns the details of the specific image passed in
    """
    folder, name = os.path.split(path)
    return gp.check_result(
        gp.gp_camera_file_get_info(camera, folder, name))


def get_renamed_files(renameFile):
    """
    Read the contents of the renamed_Files file and return the original filenames as a list
    """
    original_filenames = []
    if os.path.isfile(renameFile):
        with open(renameFile, 'rt') as f:
            for line in f:
                if ' ' in line:
                    original_filenames.append(line.split(' ')[0])
    else:
        app.logger.info('get_renamed_files() reports there\'s no renameFile')
    return original_filenames


def files_to_copy(camera):
    newFilesList = []
    if not os.path.isdir(PI_PHOTO_DIR):
        os.makedirs(PI_PHOTO_DIR)
    computer_files = list_Pi_Images(PI_PHOTO_DIR)
    camera_files = list_camera_files(camera)
    renamed_files = get_renamed_files(PI_PHOTO_RENAME_FILE)
    if not camera_files:
        app.logger.info('files_to_copy() reports no files found on the camera')
        return
    for path in camera_files:
        # This skips copying an image if its entire path is in the PI_PHOTO_RENAME_FILE.
        # As of 4.6.3 this file becomes an archive of EVERY image we've previously copied,
        # so we don't repeat copying images that are deliberately left on the camera but deleted off the Pi. (DeleteAfterCopy=False, DeleteAfterTransfer=True)
        try:
            dcimIndex = path.index("/DCIM/") # The path from the camera should contain "/DCIM/" - it's basically the root of any digital camera's image folder tree
            shortPath = path[(dcimIndex + 6):]
            if shortPath in renamed_files:
                continue
        except IndexError:
            # Nope, not there. Try alternative treatment:
            app.logger.info(f'files_to_copy() failed to find /DCIM/ in {path}')
        except Exception as e:
            app.logger.debug(f'files_to_copy() threw unexpectedly on the /DCIM/ test: {e}')

        # Legacy code. Some or all of this is earmarked to go:
        sourceFolderTree, imageFileName = os.path.split(path)
        dest = CreateDestPath(sourceFolderTree, PI_PHOTO_DIR)
        dest = os.path.join(dest, imageFileName)
        if dest in computer_files:
            continue
        if imageFileName in renamed_files:
            continue
        newFilesList.append(path)
    newFilesList.sort()
    return newFilesList


def copy_files(camera, imageToCopy, deleteAfterCopy, renameOnCopy, renameString):
    """
    Straight from Jim's examples again
    The test for available HDD space is from examples/copy-data.py
    """
    app.logger.debug('Copying files...')
    sourceFolderTree, imageFileName = os.path.split(imageToCopy)
    dest = CreateDestPath(sourceFolderTree, PI_PHOTO_DIR)
    dest = os.path.join(dest, imageFileName)
    dcimPath = dest.replace((PI_PHOTO_DIR  + "/DCIM/"), "")
    app.logger.debug(f'Copying {imageToCopy} --> {dest}')
    try:
        imageMtime = get_camera_file_info(camera, imageToCopy).file.mtime
        #This is ugly. The epoc time that comes from the camera is *assumed* to be GMT, where this is not necessarily the case:
        imageTimestamp = datetime.utcfromtimestamp(imageMtime).astimezone()
        imageTimestamp = imageTimestamp.replace(tzinfo=timezone.utc)
        imageMtime = int(imageTimestamp.strftime('%s'))
        app.logger.info(f'imageMtime {imageMtime} is of type {type(imageMtime)}')
        camera_file = gp.check_result(gp.gp_camera_file_get(
            camera, sourceFolderTree, imageFileName, gp.GP_FILE_TYPE_NORMAL))
        file_data = gp.check_result(gp.gp_file_get_data_and_size(camera_file))
        data = memoryview(file_data)
        _, piDiskFree = getDiskSpace()
        if piDiskFree - len(data) <= PI_SPACE_RESERVED:
            app.logger.info('copy_files: Insufficient disk space')
            return -1 #Abort
        copyOK = gp.check_result(gp.gp_file_save(camera_file, dest))
        if (copyOK >= gp.GP_OK):
            os.utime(dest, (imageMtime, imageMtime)) #Update mtime with the value from the camera
            newName = None
            if (renameOnCopy == True):
                if renameString:
                    newName = renameFile(dest, renameString)
                    newName = newName.replace((PI_PHOTO_DIR  + "/DCIM/"), "") # Trim the path for brevity
            if not newName:
                newName = imageFileName #If renameFile err'd, paste in the original filename. And do it anyway if renameOnCopy == False
            if (deleteAfterCopy == True):
                gp.check_result(gp.gp_camera_file_delete(camera, sourceFolderTree, imageFileName))
                app.logger.info(f'Deleted {sourceFolderTree}/{imageFileName}')
            else:
                # The rename file here does double-duty. It links original & new names, and also protects us when deleteAfterCopy is OFF, but deleteAfterTransfer is ON
                try:
                    with open(PI_PHOTO_RENAME_FILE, "a") as f:
                        f.write(f'{dcimPath} {newName}\r\n')
                except Exception as e:
                    app.logger.info(f'copy_files: renameFile error writing to PI_PHOTO_RENAME_FILE: {e}')
        else:
            app.logger.info(f"copy_files: image {dest} did not return 'GP_OK'")
            return 1
    except Exception as e:
        app.logger.info(f'copy_files exception : {e}')
        return 1
    return 0


def CreateDestPath(folder, NewDestDir):
    try:
        ImageSubDir = re.search(("DCIM/\S*"), folder)
        if ImageSubDir != None:
            subdir = os.path.join(NewDestDir, ImageSubDir.group(0))
            # app.logger.debug('Subdir =  ' + subdir)
            try:
                if not os.path.isdir(subdir):
                    os.makedirs(subdir)
            except:
                app.logger.debug(f"Didn't want to make {subdir}")
            dest = os.path.join(NewDestDir, subdir)
            # app.logger.debug(f'Pi dest = {dest}')
        else:
            dest = NewDestDir
    except Exception as e:
        app.logger.debug(f'Error in DCIM decoder: {e}')
        dest = NewDestDir
    return dest


def createDestFilename(imageFullFilename, targetFolder, suffix):
    """
    Called by 'makeThumb', /main and /thumbnails
    Manipulates the path and filename of every image:
    - Changes its source path to the targetFolder directory
    - And adds the nominated suffix
    """
    sourceFolderTree, imageFileName = os.path.split(imageFullFilename)
    dest = CreateDestPath(sourceFolderTree, targetFolder)
    dest = os.path.join(dest, imageFileName)
    dest = (f'{os.path.splitext(dest)[0]}{suffix}.JPG')
    return dest


def renameFile(imageFullFilename, renameString):
    try:
        imageFolderTree, originalFileName = os.path.split(imageFullFilename)
        fileName, fileExt = os.path.splitext(originalFileName)

        #Read the creationTime from Exif. If that fails, default to the file creation datestamp
        #dateStamp = getCreationTime(imageFullFilename)
        #if not dateStamp:
        dateStamp = datetime.fromtimestamp(os.path.getmtime(imageFullFilename))

        #Populate the variables from the file's dateStamp:
        pcF = fileName                               #Filename
        pcY = dateStamp.strftime('%Y')               #Year (20xx)
        pcm = dateStamp.strftime('%m').rjust(2, '0') #Month (01-12)
        pcb = dateStamp.strftime('%b')               #Short month ('Jan')
        pcd = dateStamp.strftime('%d').rjust(2, '0') #Day (01-31)
        pca = dateStamp.strftime('%a')               #Short day ('Mon')
        pcH = dateStamp.strftime('%H').rjust(2, '0') #Hour (00-23)
        pcM = dateStamp.strftime('%M').rjust(2, '0') #Min (00-59)
        pcS = dateStamp.strftime('%S').rjust(2, '0') #Sec (00-59)
        #Substitute the values
        renameString = renameString.replace('%F',pcF)
        renameString = renameString.replace('%Y',pcY)
        renameString = renameString.replace('%m',pcm)
        renameString = renameString.replace('%b',pcb)
        renameString = renameString.replace('%d',pcd)
        renameString = renameString.replace('%a',pca)
        renameString = renameString.replace('%H',pcH)
        renameString = renameString.replace('%M',pcM)
        renameString = renameString.replace('%S',pcS)
        app.logger.info(f'reconstituted renameString = {renameString}')
        #Rebuild the string
        renamedFile = os.path.join(imageFolderTree, renameString) + fileExt
        app.logger.info(f'renamedFile = {renamedFile}')
        try:
            suffix = 1
            safetyNet = False
            while True:
                if os.path.isfile(renamedFile):
                    #The new name already exists. Loop with a new suffix until it doesn't
                    renamedFile = os.path.join(imageFolderTree, renameString) + '-' + str(suffix) + fileExt
                    if suffix >= 1000:
                        #This is a safety net.
                        #You MIGHT be deliberately doing this (say, sequentially numbering all the files in a given year-month-day-hour), but...
                        # if we get to 1000 I'm going to abort, otherwise we risk looping here forever.
                        app.logger.info(f'renameFile safety net fired renaming file {imageFullFilename} to {renameString}.{fileExt}')
                        safetyNet = True
                        break
                    suffix += 1 #Increment the suffix and loop.
                else:
                    break
            if not safetyNet == True:
                app.logger.info(f'renameFile about to rename file {imageFullFilename} to {renameString}')
                os.rename(imageFullFilename,renamedFile)
        except Exception as e:
            app.logger.info(f'renameFile error  renaming file {imageFullFilename} to {renameString}')
            app.logger.info(f'renameFile error : {e}')
    except Exception as e:
        app.logger.info(f'renameFile unhandled error: {e}')
    return renamedFile


def getCreationTime(imageFullFilename):
    '''
    Called by renameFile to pull the datestamp of the photo's creation from its exifData.
    Use PIL if it's a JPG, or the slower exifreader if it's anything else.
    [See /var/log/celery/celery_worker.log for what happens here]
    ** Not currently in use. I wrote this BEFORE finding the 'getctime' fix...
    '''
    try:
        if imageFullFilename.endswith(RAWEXTENSIONS):
            with open(imageFullFilename, 'rb') as photo:
                tags = exifreader.process_file(photo) # Returns Exif
                creation = str(tags['EXIF DateTimeOriginal'])
        else:
            img = Image.open(imageFullFilename)
            exif = img.getexif()
            creation = exif.get(36867) # 'DateTimeOriginal'. creation is a STRING
        dateTimeOriginal = datetime.strptime(creation, '%Y:%m:%d %H:%M:%S')

    except Exception as e:
        app.logger.info(f'getCreationTime unhandled error: {e}')
        return None

    #app.logger.info(f'getCreationTime returned: {dateTimeOriginal}')
    return dateTimeOriginal


def makeThumb(imageFile):
    """
    Upgraded to use rawpy 27th May 2023. References:
    https://github.com/letmaik/rawpy
    https://github.com/letmaik/rawpy/issues/147#issuecomment-1398974494
    """
    try:
        ThumbList = list_Pi_Images(PI_THUMBS_DIR)
        _, imageFileName = os.path.split(imageFile)
        dest = createDestFilename(imageFile, PI_THUMBS_DIR, '-thumb')
        app.logger.debug(f'Thumb dest = {dest}')
        alreadyExists = False
        if dest in ThumbList:
            app.logger.debug('Thumbnail already exists.') #This logs to /var/log/celery/celery_worker.log
            alreadyExists = True
        else:
            app.logger.info(f'We need to make a thumbnail of {imageFile}') #This logs to /var/log/celery/celery_worker.log
            if imageFile.endswith(RAWEXTENSIONS):
                #It's a RAW. See if we can extract a large-format JPG to use internally
                previewfilename = createDestFilename(imageFile, PI_PREVIEW_DIR, '-preview')
                if not os.path.isfile(previewfilename):
                    try:
                        with rawpy.imread(imageFile) as raw:
                            # raises rawpy.LibRawNoThumbnailError if thumbnail missing
                            # raises rawpy.LibRawUnsupportedThumbnailError if unsupported format
                            thumb = raw.extract_thumb()
                        if thumb.format == rawpy.ThumbFormat.JPEG:
                            # thumb.data is already in JPEG format, save as-is
                            with open(previewfilename, 'wb') as f:
                                f.write(thumb.data)
                        elif thumb.format == rawpy.ThumbFormat.BITMAP:
                            # thumb.data is an RGB numpy array, convert with imageio
                            imageio.imsave(previewfilename, thumb.data)
                        else:
                            app.logger.info("makeThumb - rawpy wasn't able to make a preview")
                    except Exception as e:
                        app.logger.info(f'makeThumb preview unhandled error: {e}')
            try:
                with Image.open(imageFile) as thumb:
                    thumb.thumbnail((160, 160), Image.Resampling.LANCZOS)
                    thumb.save(dest, "JPEG")
            except Exception as e:
                app.logger.info(f'makeThumb thumbnail save error: {e}')
        getExifData(imageFile, imageFileName)
        return dest, alreadyExists
    except Exception as e:
        app.logger.info(f'Unknown Exception in makeThumb: {e}')
        return None, None


def getExifData(imageFilePath, imageFileName):
    while True:
        #Lots of TRYs here to minimise any bad data errors in the output.
        try:
            # Open image file for reading (binary mode)
            abort = None
            with open(imageFilePath, 'rb') as photo:
                tags = exifreader.process_file(photo) # Return Exif tags.
            try:
                dateOriginal = ''
                timeOriginal = ''
                dateTimeOriginal = str(tags['EXIF DateTimeOriginal']).split(' ')
                dateOriginal = (dateTimeOriginal[0]).replace(':', '/')
                timeOriginal = dateTimeOriginal[1]
            except Exception as e:
                app.logger.info(f'getExifData dateTimeOriginal error: {e}')
            if os.path.isfile(PI_THUMBS_INFO_FILE):
                with open(PI_THUMBS_INFO_FILE, 'rt') as f:
                    for line in f:
                        if (f'{imageFileName} = {dateOriginal} {timeOriginal}|') in line:
                            app.logger.info(f'getExifData image {imageFileName} already exists in Exif file. Aborting')
                            abort = True
                            break
            if abort:
                break
            try:
                _, fileExtension = os.path.splitext(imageFilePath)
                fileExtension = fileExtension.upper().replace('.', '') #Convert to upper case and delete the dot
            except Exception as e:
                fileExtension = '?'
                app.logger.info(f'getExifData fileExtension error: {e}')
            try:
                #Reformat depending on the value:
                # 6/1   becomes 6s
                # 15/10 becomes 1.5s
                # 3/10  becomes 0.3s
                # 1/30  becomes 1/30s
                exposureTime = convert_to_float(str(tags['EXIF ExposureTime']))
                if (exposureTime).is_integer():
                    #It's a whole number of seconds. Strip the '.0'
                    exposureTime = str(exposureTime).replace('.0','')
                elif (Decimal(exposureTime).as_tuple().exponent <= -2):
                    #Yuk. it has lots of decimal places. Display as originally reported
                    exposureTime = str(tags['EXIF ExposureTime'])
                else:
                    pass #We'll stick with the originally calculated exposure time, which will be 1 decimal place below 1s, e.g. 0.3
            except Exception as e:
                exposureTime = '?'
                app.logger.info(f'getExifData ExposureTime error: {e}')
            try:
                fNumber = str(convert_to_float(str(tags['EXIF FNumber'])))
                #Strip the '.0' if it's a whole F-stop
                fNumber = fNumber.replace('.0','')
            except Exception as e:
                fNumber = '?'
                app.logger.info(f'getExifData fNumber error: {e}')
            try:
                ISO = tags['EXIF ISOSpeedRatings']
            except Exception as e:
                ISO = '?'
                app.logger.info(f'getExifData ISO error: {e}')
            try:
                with open(PI_THUMBS_INFO_FILE, "a") as thumbsInfoFile:
                    thumbsInfoFile.write(f'{imageFileName} = {dateOriginal} {timeOriginal}|{fileExtension} &bull; {exposureTime}s &bull; F{fNumber} &bull; ISO{ISO}\r\n')
            except Exception as e:
                app.logger.info(f'getExifData error writing to thumbsInfoFile: {e}')
            break
        except Exception as e:
            app.logger.info(f'getExifData EXIF error: {e}')
            break
    return


def dedupeExifData():
    lines = 0
    ThumbsInfo = {}
    if os.path.isfile(PI_THUMBS_INFO_FILE):
        with open(PI_THUMBS_INFO_FILE, 'rt') as f:
            for line in f:
                if ' = ' in line:
                    try:
                        lines += 1
                        (key, val) = line.rstrip('\n').split(' = ')
                        ThumbsInfo[key] = val
                    except Exception as e:
                        #Skip over bad line
                        app.logger.debug(f'dedupeExifData info file error: {e}')
        if lines != len(ThumbsInfo):
            #We have a discrepancy (dupe or bad line). Re-write the file:
            app.logger.info(f'dedupeExifData recreating thumbs info file: lines = {lines}, UniqueImages = {len(ThumbsInfo)}')
            with open(PI_THUMBS_INFO_FILE, 'r+') as file:
                file.seek(0)
                for key, value in ThumbsInfo.items():
                    file.write(f'{key} = {value}\n')
                file.truncate() #Trash the leftovers.
    return


#TY SO: https://stackoverflow.com/a/30629776
def convert_to_float(frac_str):
    """
    The EXIF exposure time and f-number data is a string representation of a fraction. This converts it to a float for display
    """
    try:
        return float(frac_str)
    except ValueError:
        num, denom = frac_str.split('/')
        try:
            leading, num = num.split(' ')
            whole = float(leading)
        except ValueError:
            whole = 0
        frac = float(num) / float(denom)
        return whole - frac if whole < 0 else whole + frac


def getPreviewImage(camera, config):
    """
    Straight out of Jim's examples
    """
    OK, image_format = gp.gp_widget_get_child_by_name(config, 'imageformat')
    if OK >= gp.GP_OK:
        # get current setting
        value = gp.check_result(gp.gp_widget_get_value(image_format))
        # make sure it's not raw
        if 'raw' in value.lower():
            app.logger.debug('Cannot preview raw images')
            return 1
    # find the capture size class config item
    # need to set this on my Canon 350d to get preview to work at all
    OK, capture_size_class = gp.gp_widget_get_child_by_name(
        config, 'capturesizeclass')
    if OK >= gp.GP_OK:
        # set value
        value = gp.check_result(gp.gp_widget_get_choice(capture_size_class, 2))
        gp.check_result(gp.gp_widget_set_value(capture_size_class, value))
        # set config
        gp.check_result(gp.gp_camera_set_config(camera, config))
    # capture preview image (not saved to camera memory card)
    app.logger.debug('Capturing preview image')
    camera_file = gp.check_result(gp.gp_camera_capture_preview(camera))
    file_data = gp.check_result(gp.gp_file_get_data_and_size(camera_file))
    # display image
    data = memoryview(file_data)
    app.logger.debug(type(data), len(data))
    app.logger.debug(data[:10].tolist())
    fileName = os.path.join(PI_PREVIEW_DIR, PI_PREVIEW_FILE)
    if os.path.isfile(fileName):
        os.remove(fileName)
    Image.open(io.BytesIO(file_data)).save(fileName, "JPEG")
    return 0


def getDiskSpace():
    """
    https://www.raspberrypi.org/forums/viewtopic.php?t=22180
    """
    try:
        disk = psutil.disk_usage('/')
        #disk_total = disk.total / 2**30     # GiB.
        #disk_used = disk.used / 2**30
        disk_free_bytes = disk.free
        disk_free_str = str(round(disk_free_bytes / 2**30,2)) + ' GB'
    except:
        return "Unknown",None
    return disk_free_str,disk_free_bytes


def createConfigFile(iniFile):
    """
    Thank you https://www.blog.pythonlibrary.org/2013/10/25/python-101-an-intro-to-configparser/
    """
    try:
        config = configparser.ConfigParser()
        config.add_section('Global')
        config.set('Global', 'file created', time.strftime("%0d %b %Y",time.localtime(time.time())))
        config.set('Global', 'locationName', HOSTNAME)
        config.set('Global', 'thumbscount', '24')
        config.add_section('Transfer')
        config.set('Transfer', 'tfrMethod', 'Off')
        config.set('Transfer', 'deleteAfterTransfer', 'Off')
        config.add_section('Copy')
        config.set('Copy', 'copyDay', 'Daily')
        config.set('Copy', 'copyHour', '14')
        config.set('Copy', 'deleteAfterCopy', 'Off')
        with open(iniFile, 'w') as config_file:
            config.write(config_file)
    except:
        app.logger.debug(f'createConfigFile Threw creating {iniFile}')
    return


def getIni(keySection, keyName, keyType, defaultValue):
    """
    Reads a key from the INI file and returns its value.
    If it doesn't exist, it's created with a default value, which is then returned
    """
    returnValue = defaultValue
    try:
        if not os.path.isfile(iniFile):
            createConfigFile(iniFile)
        config = configparser.ConfigParser()
        config.read(iniFile)
        if 'bool' in keyType:
            returnValue = config.getboolean(keySection, keyName)
        else:
            returnValue = config.get(keySection, keyName)
    except configparser.Error as e:
        app.logger.info(f'getIni reports key error: {e}')
        #Looks like the flag doesn't exist. Let's add it
        setIni(keySection, keyName, defaultValue)
    except Exception as e:
        app.logger.info(f'Unhandled error in getIni: {e}')
    return returnValue


def setIni(keySection, keyName, newValue):
    """
    Update an existing INI file key value, or add a new one
    """
    try:
        if not os.path.isfile(iniFile):
            createConfigFile(iniFile)
        config = configparser.ConfigParser()
        config.read(iniFile)
    except Exception as e:
        app.logger.info(f'Unhandled error in setIni: {e}')
    try:
        if not config.has_section(keySection):
            config.add_section(keySection)
        config.set(keySection, keyName, newValue)
        with open(iniFile, 'w') as config_file:
            config.write(config_file)
        app.logger.debug(f'Added key {keySection}/{keyName} with {newValue = }') # Strange but true, this syntax prints the variable's name & value between single-quotes
    except Exception as e:
        app.logger.debug(f'Exception thrown trying to add key {keySection}/{keyName} with {newValue = }')


@app.route('/trnCopyNow', methods=['POST'])
@login_required
def trnCopyNow():
    """
    This page is called in the background by the 'Copy now' button on the Transfer page
    It kicks off the background task, and returns the taskID so its progress can be followed
    """
    app.logger.debug('trnCopyNow() entered. [See /var/log/celery/celery_worker.log for what happens here]')

    tasks = [copyNow.si()]
    tasks.append(newThumbs.si())

    task = chain(*tasks).apply_async()

    app.logger.debug(f'trnCopyNow() returned with task_id= {task.id}')
    return jsonify({}), 202, {'Location': url_for('backgroundStatus', task_id=task.id)}


@celery.task(time_limit=1800, bind=True)
def copyNow(self):
    writeString("WC", 1) # Sends the camera WAKE command to the Arduino
    app.logger.info('copyNow entered') #This logs to /var/log/celery/celery_worker.log
    camera = gp.Camera()
    context = gp.gp_context_new()
    retries = 0
    filesToCopy = []
    while True:
        time.sleep(1);  # Pause between retries
        retries += 1
        if retries >= 6:
            #We've waited too long. Abort.
            app.logger.info(f'copyNow could not claim the USB device after {retries} attempts.')
            return {'status': 'USB error', 'statusColour': 'red'}
        try:
            app.logger.info('copyNow trying to init the camera')
            camera.init(context)
            #The line above will throw an exception if we can't connect to the camera
            app.logger.info('copyNow camera initialised')
            break
        except gp.GPhoto2Error as e:
            app.logger.info(f"copyNow wasn't able to connect to the camera: {e.string}")
            continue
        except Exception as e:
            app.logger.info(f'Unknown error in copyNow: {e}')
            continue
    self.update_state(state='PROGRESS', meta={'status': 'Preparing to copy images', 'statusColour': 'white'})
    thisImage = 0
    errorFlag = 0
    filesToCopy = files_to_copy(camera)
    if filesToCopy:
        numberToCopy = len(filesToCopy)
        app.logger.info(f'copyNow has been tasked with copying {numberToCopy} images')
        deleteAfterCopy = getIni('Copy', 'deleteAfterCopy', 'bool', 'Off')
        renameOnCopy = getIni('Copy', 'renameOnCopy', 'bool', 'Off')
        renameString = getIni('Copy', 'renameString', 'string', None)
        if not renameString:
            app.logger.info('copyNow reports renameString is blank/empty. Forcing renameOnCopy = False')
            renameOnCopy = False
        while len(filesToCopy) > 0:
            try:
                self.update_state(state='PROGRESS', meta={'status': 'Copying image ' + str(thisImage + 1) + ' of ' + str(numberToCopy), 'statusColour': 'white'})
                thisFile = filesToCopy.pop(0)
                app.logger.info(f'About to copy file: {thisFile}')
                copyResult = copy_files(camera, thisFile, deleteAfterCopy, renameOnCopy, renameString)
                if copyResult == 0:
                    thisImage += 1
                elif copyResult == -1:
                    #Fatal - out of drive space.
                    errorFlag = -1
                    break
                else:
                    errorFlag = 1
            except Exception as e:
                app.logger.info(f'Unknown error in copyNow: {e}')
    try:
        camera.exit()
        app.logger.info('copyNow ended without fatal exception')
    except Exception as e:
        app.logger.info(f'copyNow ended with unhandled exception: {e}')
    if thisImage == 1:
        imageString = "image"
    else:
        imageString = "images"
    if errorFlag == -1:
        app.logger.info('copyNow reported fatal: out of drive space')
        statusMessage = 'Out of drive space'
        statusColour = 'red'
    elif errorFlag == 1:
        app.logger.info('copyNow reported 1 or more errors')
        statusMessage = (f'Errors reported. Copied {thisImage} {imageString} OK')
        statusColour = 'orange'
    elif thisImage == 0:
        app.logger.info('copyNow reported there were no new images to copy')
        statusMessage = 'There were no new images to copy'
        statusColour = 'white'
    else:
        statusMessage = (f'Copied {thisImage} {imageString} OK')
        statusColour = 'white'
    return {'status': statusMessage, 'statusColour': statusColour}


@celery.task(time_limit=1800, bind=True)
def newThumbs(self):
    app.logger.info('newThumbs() entered') #This logs to /var/log/celery/celery_worker.log
    if int(getIni('Global', 'thumbsCount', 'int', '24')) == 0:
        # If thumbs = 0, we'll silently create one thumbnail/preview image, for the benefit of the home page
        silentMode = True
        app.logger.info('newThumbs running in silentMode. Only doing the most recent image')
    else:
        silentMode = False
        self.update_state(state='PROGRESS', meta={'status': 'Commencing thumbnail creation', 'statusColour': 'white'})

    thumbsCreated = 0
    try:
        FileList  = list_Pi_Images(PI_PHOTO_DIR)
        if silentMode:
            # Truncate the file list to ONLY the most recent image
            FileList.sort(key=lambda x: os.path.getmtime(x))
            FileList = FileList[-1:]
        ThumbList = list_Pi_Images(PI_THUMBS_DIR)

        DifferenceList = []
        for image in FileList:
            newImageThumb = os.path.splitext(image)[0] + '-thumb.JPG'
            newImageThumb = newImageThumb.replace(PI_PHOTO_DIR,PI_THUMBS_DIR)
            if newImageThumb not in ThumbList:
                #Check for and remove any dupes.
                if image.endswith(RAWEXTENSIONS):
                    if re.sub('|'.join(RAWEXTENSIONS), '.JPG', image) in DifferenceList:
                        DifferenceList.remove(re.sub('|'.join(RAWEXTENSIONS), '.JPG', image)) # A raw trumps a JPG.
                elif image.endswith('.JPG'):
                    discarded = False
                    for RAW in RAWEXTENSIONS:
                        if image.replace('.JPG', RAW) in DifferenceList:
                            #Discard a JPG if there's already a RAW of the same name in the list
                            discarded = True #You can't 'continue' out of nested loops in Python
                    if discarded: continue
                DifferenceList.append(image)
        thumbsToCreate = len(DifferenceList)
        app.logger.info(f'Thumbs to create = {thumbsToCreate}')

        if thumbsToCreate >= 1:
            for loop in range(-1, (-1 * (thumbsToCreate + 1)), -1):
                self.update_state(state='PROGRESS', meta={'status': 'Creating thumbnail ' + str(thumbsCreated + 1) + ' of ' + str(thumbsToCreate), 'statusColour': 'white'})
                dest, alreadyExists = makeThumb(DifferenceList[loop]) #Create a thumb, and metadata for every image on the Pi
                if (dest == None):
                    #Something went wrong
                    app.logger.info(f'A thumb was not created for {DifferenceList[loop]}')
                    continue
                if not alreadyExists:
                    thumbsCreated += 1
                    if not silentMode:
                        self.update_state(state='PROGRESS', meta={'status': 'Created thumbnail ' + str(thumbsCreated) + ' of ' + str(thumbsToCreate), 'statusColour': 'white'})
                    app.logger.info(f'Thumb  of {DifferenceList[loop]} is {dest}')
                else:
                    app.logger.info(f'Thumb for {dest} already exists')
        else:
            app.logger.info('newThumbs reports there are no thumbsToCreate.')
    except Exception as e:
        app.logger.info(f'newThumbs error: {e}')
    dedupeExifData()
    app.logger.info('newThumbs returned')
    if silentMode:
        return {'status': 'Creation of thumbnail images skipped', 'statusColour': 'white'}
    else:
        return {'status': 'Created ' + str(thumbsCreated) + ' thumbnail images OK', 'statusColour': 'white'}


# TY Miguel: https://blog.miguelgrinberg.com/post/using-celery-with-flask
@app.route('/backgroundStatus/<task_id>')
@login_required
def backgroundStatus(task_id):
    task = copyNow.AsyncResult(task_id)
    app.logger.debug(f'backgroundStatus entered with task_id = {task_id} and task.state = {task.state}')
    if task.state == 'PENDING':
        # job did not start yet
        response = {
            'state': task.state,
            'status': 'Background task pending',
            'statusColour': 'white'
        }
    elif task.state != 'FAILURE':
        response = {
            'state': task.state,
            'status': task.info.get('status', '')
        }
        try:
            response['statusColour'] = task.info.get('statusColour', '')
        except Exception as e:
            app.logger.info(f'backgroundStatus error 1. The task has no statusColour: {e}')
    else:
        # something went wrong in the background job
        app.logger.debug(f'Something went wrong in the background job: {task.info}')
        response = {
            'state': task.state,
            'status': str(task.info)  # this is the exception raised
        }
        try:
            response['statusColour'] = task.info.get('statusColour', '')
        except Exception as e:
            app.logger.info(f'backgroundStatus error 2. The task has no statusColour: {e}')
    app.logger.debug('backgroundStatus returned')
    return jsonify(response)


# https://stackoverflow.com/questions/5544629/retrieve-list-of-tasks-in-a-queue-in-celery
@app.before_request
def getCeleryTasks():
    """
    This executes before EVERY page load, feeding any active task ID into the
    ensuing response. Javascript in the footer of every page (in index.html)
    will then query for status updates if a task ID is present
    """
    try:
        # Inspect all nodes.
        i = celery.control.inspect(['celery_worker@' + HOSTNAME])
        d = i.stats()
        if not d:
            app.logger.debug('getCeleryTasks reports no Celery workers running.')
            try:
                if current_user.is_authenticated:
                    # Prevents leak of message if user=anon
                    flash('There are no Celery workers running', 'red')
            except:
                # No user?
                pass
            return
        # Show tasks that are currently active.
        activeTasks = i.active()
        if activeTasks != None:
            for _, tasks in list(activeTasks.items()):
                if tasks:
                    g.taskstr = ','.join("%s" % (t['id']) for t in tasks[:1]) #Just the first task will do
                else:
                    #app.logger.debug('getCeleryTasks cleared g.taskstr')
                    g.taskstr = None
            #app.logger.debug(f'getCeleryTasks g.taskstr = {g.taskstr}')
        else:
            app.logger.debug('getCeleryTasks reports there are no activeTasks')
    except Exception as e:
        app.logger.debug(f'getCeleryTasks exception: {e}')


@app.route("/iniview")
@login_required
def iniview():
    """
    Displays the content of the ini file
    """
    iniEntries = []
    try:
        config = configparser.ConfigParser()
        config.read(iniFile)
        for section_name in config.sections():
            iniEntries.append({'section': str(section_name), 'key': '', 'value': '' })
            for name, value in config.items(section_name):
                iniEntries.append({'section': str(section_name), 'key': name, 'value': value })
    except Exception as e:
        app.logger.debug(f'iniview error: {e}')
        flash('INI error', 'red')
    return render_template('iniview.html', iniEntries = iniEntries)


@app.route("/network")
@login_required
def network():
    """
    A 'hidden' page (not in the main menu) that displays wifi & wired networking stats and diagnostic information
    """
    networkData = []
    wifiData = []
    try:
        interfaces = psutil.net_if_addrs()
        ifstats = psutil.net_if_stats()
        networkData.append({'section': 'Network interfaces', 'key': '', 'value': '' })
        for interface in interfaces.keys():
            if interface in 'lo':
                continue
            networkData.append({'section': interface, 'key': '', 'value': '' })
            statsTuple = ifstats[interface]
            isup = str(getattr(statsTuple, 'isup'))
            networkData.append({'section': interface, 'key': 'isup', 'value': isup })
            if 'wlan' in interface and isup == 'True':
                # Add the SSID and related data before the IP values
                cmd = ['/usr/sbin/iwgetid', '-r']
                ssid = runSubprocess(cmd, 'Unknown')
                networkData.append({'section': interface, 'key': 'ssid', 'value': ssid })
            ipList = interfaces[interface]
            for type in ipList:
                # app.logger.info(f'network says type is {type}')
                if type.family != socket.AF_INET:
                    # Suppress display of IPv6 and others
                    continue
                for ipvalue in type._fields:
                    if ('family') in ipvalue:
                        # Suppress display of unwanted values
                        continue
                    # app.logger.info(f'ipvalue = {ipvalue}')
                    networkData.append({'section': interface, 'key': ipvalue, 'value': getattr(type, ipvalue) })
            for field in statsTuple._fields:
                if field in 'isup':
                    continue # Skip it - we pulled it earlier
                networkData.append({'section': interface, 'key': field, 'value': (getattr(statsTuple, field)) })

        # Loop through the interfaces again, pulling out the WiFi ones.
        for interface in interfaces.keys():
            if 'wlan' not in interface:
                continue
            # Now scan & display any available WiFi networks.
            wifi_data = scan_wifi_networks(interface)
            wifiData.append({'section': 'Available WiFi networks', 'key': '', 'value': '' })
            wifiData.append({'section': interface, 'key': '', 'value': '' })
            if len(wifi_data) == 0:
                wifiData.append({'section': interface, 'key': '', 'value': 'none found' })
            for i in range(len(wifi_data)):
                for key in wifi_data[i]:
                    wifiData.append({'section': interface, 'key': key, 'value': wifi_data[i][key] })
    except Exception as e:
        app.logger.debug(f'network error: {e}')
        flash('Unknown error', 'red')
    return render_template('network.html', networkData = networkData, wifiData = wifiData)


def scan_wifi_networks(interface):
    """
    Scans the nearby WiFi networks and displays the results.

    A hybrid of:
    https://github.com/Xilef12000/RPi0w-wifi-catcher/blob/main/iwlist.py

    Returns:
    - list of dictionaries:
        A list of dictionaries containing the details of each WiFi network.
        Each dictionary contains the following keys:
        - 'SSID': The name of the WiFi network.
        - 'BSSID': The MAC address of the WiFi network.
        - 'Signal': The signal strength of the WiFi network in dBm.
        - 'Channel': The channel number of the WiFi network.
    """

    # Run the command to scan for nearby WiFi networks using the 'iwlist' command.
    # The output will be in the form of a byte string.
    cmd = (f'/usr/bin/sudo /usr/sbin/iwlist {interface} scan')
    output = os.popen(cmd).read()
    # Split the output into lines.
    networks = output.split('    Cell ')
    # Initialize an empty list to store each WiFi network's details.
    wifi_networks = []

    for network in networks:
        lines = network.split('\n')
        # Iterate over the lines to extract the WiFi network details.
        for line in lines:
            line = line.strip()
            # Check if the line contains the SSID (network name).
            if 'ESSID' in line:
                # Extract the SSID from the line.
                ssid = line.split(':')[1].strip().strip('"')
                # Initialize a dictionary to store the details of the WiFi network.
                wifi_network = {'SSID': ssid}

        # Iterate over the lines to extract the WiFi network details.
        for line in lines:
            line = line.strip()
            # Check if the line contains the BSSID (MAC address).
            if 'Address' in line:
                # Extract the BSSID from the line.
                bssid = line.split()[3]
                # Add the BSSID to the dictionary.
                wifi_network['BSSID'] = bssid
            # Check if the line contains the signal strength.
            elif 'Signal level' in line:
                # Extract the signal strength from the line.
                signal = line.split('=')[2]#.split()[0]
                # Add the signal strength to the dictionary.
                wifi_network['Signal'] = signal
                quality = line.split('=')[1].split('/')[0]
                # Add the signal strength to the dictionary.
                wifi_network['Quality'] = quality
            # Check if the line contains the channel number.
            elif 'Channel:' in line:
                # Extract the channel number from the line.
                channel = line.split(':')[1]
                # Add the channel number to the dictionary.
                wifi_network['Channel'] = channel
                # Add the dictionary to the list of WiFi networks.
                wifi_networks.append(wifi_network)
    # Return the list of WiFi networks.
    return wifi_networks


def runSubprocess(cmd, returnValue=None):
    """
    Accepts a command to run & returns the outcome (if successful).
    On error, logs the resulting 'stderrdata' and sends back the provided returnValue
    """
    calledBy = inspect.stack()[1][3]
    try:
        result = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False, encoding='utf-8')
        (stdoutdata, stderrdata) = result.communicate()
        if stdoutdata:
            returnValue = stdoutdata.strip()
        if stderrdata:
            stderrdata = stderrdata.strip()
            app.logger.debug(f'{calledBy} called runSubprocess which returned errdata: {stderrdata}')
    except Exception as e:
        app.logger.debug(f'{calledBy} called runSubprocess which threw: {e}')
    return returnValue


def reformatSlashes(folder):
    """
    Reformat the user's remote folder value:
    1) Convert any backslashes to slashes
    2) Convert any double slashes to singles
    """
    while '\\' in folder:
        folder = folder.replace('\\', '/') # Escaping means the '\\' here is seen as a single backslash
    while '//' in folder:
        folder = folder.replace('//', '/')
    return folder


def getLargestImageSize(path):
    """
    Finds the largest file on the /photos/ folder tree.
    Used to calculate the number of days' worth of storage left on the Pi
    """
    max_size = 100000
    try:
        for folder, subfolders, files in os.walk(path):
            # checking the size of each file
            for file in files:
                size = os.stat(os.path.join( folder, file  )).st_size
                # updating maximum size
                if size > max_size:
                    max_size = size
        app.logger.debug(f'getLargestImageSize returned: {max_size}')
    except Exception as e:
        app.logger.debug(f'getLargestImageSize exception: {e}')
    return max_size


def getShotsPerDay():
    """
    Used to calculate the number of days' worth of storage left on the Pi and camera
    """
    shotsPerDay = 0
    try:
        ArdInterval = str(readFromArduino("3", "String", True))
        #Returns a string that's <DAY> (a byte to be treated as a bit array of days) followed by 2-digit strings of <startHour>, <endHour> & <Interval>:
        if (ArdInterval != "Unknown") & (len(ArdInterval) == 7):
            startHour = int(ArdInterval[1:3])
            endHour   = int(ArdInterval[3:5])
            interval  = int(ArdInterval[5:7])

            if (interval > 60):
                shotsPerHour = 60 * (60 / (interval - 60))
            else:
                shotsPerHour = (60 / interval)

            if endHour >= startHour:
                shotsPerDay = (endHour - startHour) * shotsPerHour
            else:
                shotsPerDay = ((endHour + 24) - startHour) * shotsPerHour # STM
            app.logger.debug(f'getShotsPerDay returned: {shotsPerDay}')
            return shotsPerDay
        else:
            return None
    except Exception as e:
        app.logger.debug(f'getShotsPerDay exception: {e}')
        return None


@app.route('/robots.txt')
def norobots():
    res = make_response("User-Agent: *\nDisallow: /\n")
    res.status_code = 200
    res.headers["Content-Type"] = "text/plain; charset=utf-8"
    return res


#This always needs to be at the end, as nothing else will run after it - it's blocking:
if __name__ == "__main__":
   # app.jinja_env.auto_reload = True             # Enable when debugging: reloads template files
   # app.config['TEMPLATES_AUTO_RELOAD'] = True   # Enable when debugging: reloads template files
   # app.run(host='0.0.0.0', debug=True)          # Toggle with below: templates won't reload without Debug
   app.run(host='0.0.0.0')
